diff Marlin/Configuration_adv.h ../DiscoEasy200/Configuration_adv.h
149c149
< //#define FAN_KICKSTART_TIME 100
---
> #define FAN_KICKSTART_TIME 100
508,509c508,509
< #if ENABLED(ULTIPANEL)
<   //#define FILAMENTCHANGEENABLE
---
> #if ENABLED(ULTIPANEL) || ENABLED(NO_LCD_FOR_FILAMENTCHANGEABLE)
>   #define FILAMENTCHANGEENABLE
511,512c511,512
<     #define FILAMENTCHANGE_XPOS 3
<     #define FILAMENTCHANGE_YPOS 3
---
>     #define FILAMENTCHANGE_XPOS 195
>     #define FILAMENTCHANGE_YPOS 195
515,516c515,516
<     #define FILAMENTCHANGE_FINALRETRACT -100
<     #define AUTO_FILAMENT_CHANGE                //This extrude filament until you press the button on LCD
---
>     #define FILAMENTCHANGE_FINALRETRACT 0
>     //#define AUTO_FILAMENT_CHANGE                //This extrude filament until you press the button on LCD
diff Marlin/Configuration.h ../DiscoEasy200/Configuration.h
43a44,47
> #define FILAMENTCHANGE_FEEDRATE_MULTIPLICATOR 5.0
> #define NO_LCD_FOR_FILAMENTCHANGEABLE
> #define PRINTER_HEAD_EASY_CONSTANT_FAN_MIN_TEMP 50
> #define PRINTER_HEAD_EASY
85c89
< #define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
---
> #define STRING_CONFIG_H_AUTHOR "Dagoma.Fr"
108c112
<   #define MOTHERBOARD BOARD_RAMPS_14_EFB
---
>   #define MOTHERBOARD BOARD_MKS_BASE
113c117
< //#define CUSTOM_MACHINE_NAME "3D Printer"
---
> #define CUSTOM_MACHINE_NAME "DiscEasy200"
165a170
> // 16 is 100K thermistor - Alternative ATC Semitec 104GT-2 (4.7k pullup) Dagoma.Fr version (measured/tested/approved)
185c190
< #define TEMP_SENSOR_0 1
---
> #define TEMP_SENSOR_0 17
196,198c201,203
< #define TEMP_RESIDENCY_TIME 10  // (seconds)
< #define TEMP_HYSTERESIS 3       // (degC) range of +/- temperatures considered "close" to the target one
< #define TEMP_WINDOW     1       // (degC) Window around target to start the residency timer x degC early.
---
> #define TEMP_RESIDENCY_TIME 15
> #define TEMP_HYSTERESIS 4
> #define TEMP_WINDOW 3
203c208
< #define TEMP_BED_WINDOW     1       // (degC) Window around target to start the residency timer x degC early.
---
> #define TEMP_BED_WINDOW 3
250,252c255,257
<   #define  DEFAULT_Kp 22.2
<   #define  DEFAULT_Ki 1.08
<   #define  DEFAULT_Kd 114
---
>   #define  DEFAULT_Kp 32.48
>   #define  DEFAULT_Ki 6.4
>   #define  DEFAULT_Kd 41.25
255,257c260,262
<   //#define  DEFAULT_Kp 7.0
<   //#define  DEFAULT_Ki 0.1
<   //#define  DEFAULT_Kd 12
---
>   //#define  DEFAULT_Kp 32.48
>   //#define  DEFAULT_Ki 6.4
>   //#define  DEFAULT_Kd 41.25
260,262c265,267
<   //#define  DEFAULT_Kp 63.0
<   //#define  DEFAULT_Ki 2.25
<   //#define  DEFAULT_Kd 440
---
>   //#define  DEFAULT_Kp 32.48
>   //#define  DEFAULT_Ki 6.4
>   //#define  DEFAULT_Kd 41.25
296,298c301,303
<   #define  DEFAULT_bedKp 10.00
<   #define  DEFAULT_bedKi .023
<   #define  DEFAULT_bedKd 305.4
---
>   #define  DEFAULT_bedKp 182.79
>   #define  DEFAULT_bedKi 14.84
>   #define  DEFAULT_bedKd 563.01
302,304c307,309
<   //#define  DEFAULT_bedKp 97.1
<   //#define  DEFAULT_bedKi 1.41
<   //#define  DEFAULT_bedKd 1675.16
---
>   //#define  DEFAULT_bedKp 182.79
>   //#define  DEFAULT_bedKi 14.84
>   //#define  DEFAULT_bedKd 563.01
364c369
< #define USE_YMIN_PLUG
---
> //#define USE_YMIN_PLUG
367c372
< //#define USE_YMAX_PLUG
---
> #define USE_YMAX_PLUG
387c392
< const bool Z_MIN_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.
---
> const bool Z_MIN_ENDSTOP_INVERTING = true;
465c470
< #define INVERT_Y_DIR true
---
> #define INVERT_Y_DIR false
477c482
< //#define MIN_Z_HEIGHT_FOR_HOMING 4 // (in mm) Minimal z height before homing (G28) for Z clearance above the bed, clamps, ...
---
> #define MIN_Z_HEIGHT_FOR_HOMING 7
484c489
< #define Y_HOME_DIR -1
---
> #define Y_HOME_DIR 1
493,494c498,499
< #define X_MIN_POS 0
< #define Y_MIN_POS 0
---
> #define X_MIN_POS -2
> #define Y_MIN_POS -1
496,498c501,503
< #define X_MAX_POS 200
< #define Y_MAX_POS 200
< #define Z_MAX_POS 200
---
> #define X_MAX_POS 205
> #define Y_MAX_POS 205
> #define Z_MAX_POS 205
542c547
< //#define AUTO_BED_LEVELING_FEATURE // Delete the comment to enable (remove // at the start of the line)
---
> #define AUTO_BED_LEVELING_FEATURE // Delete the comment to enable (remove // at the start of the line)
565,568c570,573
<     #define LEFT_PROBE_BED_POSITION 15
<     #define RIGHT_PROBE_BED_POSITION 170
<     #define FRONT_PROBE_BED_POSITION 20
<     #define BACK_PROBE_BED_POSITION 170
---
>     #define LEFT_PROBE_BED_POSITION 18
>     #define RIGHT_PROBE_BED_POSITION 182
>     #define FRONT_PROBE_BED_POSITION 58
>     #define BACK_PROBE_BED_POSITION 148
593,594c598,599
<   // #define X_PROBE_OFFSET_FROM_EXTRUDER 10
<   // #define Y_PROBE_OFFSET_FROM_EXTRUDER 10
---
>   // #define X_PROBE_OFFSET_FROM_EXTRUDER 0
>   // #define Y_PROBE_OFFSET_FROM_EXTRUDER 21
606,608c611,613
<   #define X_PROBE_OFFSET_FROM_EXTRUDER 10  // X offset: -left  +right  [of the nozzle]
<   #define Y_PROBE_OFFSET_FROM_EXTRUDER 10  // Y offset: -front +behind [the nozzle]
<   #define Z_PROBE_OFFSET_FROM_EXTRUDER 0   // Z offset: -below +above  [the nozzle]
---
>   #define X_PROBE_OFFSET_FROM_EXTRUDER 0
>   #define Y_PROBE_OFFSET_FROM_EXTRUDER 21
>   #define Z_PROBE_OFFSET_FROM_EXTRUDER 0
625c630
<   //#define FIX_MOUNTED_PROBE
---
>   #define FIX_MOUNTED_PROBE
668c673
< //#define Z_SAFE_HOMING
---
> #define Z_SAFE_HOMING
686,692c691,697
< #define DEFAULT_AXIS_STEPS_PER_UNIT   {80,80,4000,500}  // default steps per unit for Ultimaker
< #define DEFAULT_MAX_FEEDRATE          {300, 300, 5, 25}    // (mm/sec)
< #define DEFAULT_MAX_ACCELERATION      {3000,3000,100,10000}    // X, Y, Z, E maximum start speed for accelerated moves. E default values are good for Skeinforge 40+, for older versions raise them a lot.
<
< #define DEFAULT_ACCELERATION          3000    // X, Y, Z and E acceleration in mm/s^2 for printing moves
< #define DEFAULT_RETRACT_ACCELERATION  3000    // E acceleration in mm/s^2 for retracts
< #define DEFAULT_TRAVEL_ACCELERATION   3000    // X, Y, Z acceleration in mm/s^2 for travel (non printing) moves
---
> #define DEFAULT_AXIS_STEPS_PER_UNIT {80,80,2560,98}
> #define DEFAULT_MAX_FEEDRATE {500, 500, 4, 170}
> #define DEFAULT_MAX_ACCELERATION {9000,3000,100,10000}
>
> #define DEFAULT_ACCELERATION 3000
> #define DEFAULT_RETRACT_ACCELERATION 3000
> #define DEFAULT_TRAVEL_ACCELERATION 3000
695,697c700,702
< #define DEFAULT_XYJERK                20.0    // (mm/sec)
< #define DEFAULT_ZJERK                 0.4     // (mm/sec)
< #define DEFAULT_EJERK                 5.0    // (mm/sec)
---
> #define DEFAULT_XYJERK 20.0
> #define DEFAULT_ZJERK 0.4
> #define DEFAULT_EJERK 5.0
726c731
< //#define EEPROM_SETTINGS
---
> #define EEPROM_SETTINGS
753c758
< #define PLA_PREHEAT_HPB_TEMP 70
---
> #define PLA_PREHEAT_HPB_TEMP 60
757c762
< #define ABS_PREHEAT_HPB_TEMP 110
---
> #define ABS_PREHEAT_HPB_TEMP 90
774c779
< #define LANGUAGE_INCLUDE GENERATE_LANGUAGE_INCLUDE(en)
---
> #define LANGUAGE_INCLUDE GENERATE_LANGUAGE_INCLUDE(fr)
815c820
< //#define SDSUPPORT
---
> #define SDSUPPORT
1037c1042
< //#define FAN_SOFT_PWM
---
> #define FAN_SOFT_PWM
Seulement dans ../DiscoEasy200/: Configuration_post.h
Seulement dans ../DiscoEasy200/: Configuration_pre.h
diff Marlin/dogm_bitmaps.h ../DiscoEasy200/dogm_bitmaps.h
39,76c39,76
<       0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
<       0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
<       0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
<       0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF,
<       0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF,
<       0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
<       0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF,
<       0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x3F, 0xFF,
<       0xC0, 0x0F, 0xC0, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x18, 0x00, 0x1F, 0xFF,
<       0xC0, 0x3F, 0xE1, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x3C, 0x00, 0x0F, 0xFF,
<       0xC0, 0x7F, 0xF3, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x78, 0x3C, 0x00, 0x07, 0xFF,
<       0xC0, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x78, 0x3C, 0x00, 0x03, 0xFF,
<       0xC1, 0xF8, 0x7F, 0x87, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x01, 0xFF,
<       0xC1, 0xF0, 0x3F, 0x03, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0xFF,
<       0xC1, 0xE0, 0x1E, 0x01, 0xE0, 0x1F, 0x00, 0x03, 0xE0, 0x78, 0x3C, 0x03, 0xF0, 0x7F,
<       0xC1, 0xE0, 0x1E, 0x01, 0xE0, 0x7F, 0xC0, 0x0F, 0xF8, 0x78, 0x3C, 0x07, 0xFC, 0x3F,
<       0xC1, 0xE0, 0x1E, 0x01, 0xE1, 0xFF, 0xE0, 0x1F, 0xFC, 0x78, 0x3C, 0x0F, 0xFE, 0x1F,
<       0xC1, 0xE0, 0x1E, 0x01, 0xE3, 0xFF, 0xF0, 0x3F, 0xFE, 0x78, 0x3C, 0x1F, 0xFE, 0x0F,
<       0xC1, 0xE0, 0x1E, 0x01, 0xE3, 0xF3, 0xF8, 0x3F, 0x3E, 0x78, 0x3C, 0x3F, 0x3F, 0x07,
<       0xC1, 0xE0, 0x1E, 0x01, 0xE7, 0xE0, 0xFC, 0x7C, 0x1F, 0x78, 0x3C, 0x3E, 0x1F, 0x07,
<       0xC1, 0xE0, 0x1E, 0x01, 0xE7, 0xC0, 0x7C, 0x7C, 0x0F, 0x78, 0x3C, 0x3C, 0x0F, 0x03,
<       0xC1, 0xE0, 0x1E, 0x01, 0xE7, 0x80, 0x7C, 0x78, 0x0F, 0x78, 0x3C, 0x3C, 0x0F, 0x03,
<       0xC1, 0xE0, 0x1E, 0x01, 0xE7, 0x80, 0x3C, 0x78, 0x00, 0x78, 0x3C, 0x3C, 0x0F, 0x03,
<       0xC1, 0xE0, 0x1E, 0x01, 0xE7, 0x80, 0x3C, 0x78, 0x00, 0x78, 0x3C, 0x3C, 0x0F, 0x03,
<       0xC1, 0xE0, 0x1E, 0x01, 0xE7, 0x80, 0x3C, 0x78, 0x00, 0x78, 0x3C, 0x3C, 0x0F, 0x03,
<       0xC1, 0xE0, 0x1E, 0x01, 0xE7, 0xC0, 0x3C, 0x78, 0x00, 0x78, 0x3C, 0x3C, 0x0F, 0x03,
<       0xC1, 0xE0, 0x1E, 0x01, 0xE3, 0xE0, 0x3C, 0x78, 0x00, 0x7C, 0x3C, 0x3C, 0x0F, 0x03,
<       0xC1, 0xE0, 0x1E, 0x01, 0xE3, 0xFF, 0x3F, 0xF8, 0x00, 0x7F, 0xBC, 0x3C, 0x0F, 0x03,
<       0xC1, 0xE0, 0x1E, 0x01, 0xE1, 0xFF, 0x3F, 0xF8, 0x00, 0x3F, 0xBF, 0xFC, 0x0F, 0x03,
<       0xC1, 0xE0, 0x1E, 0x01, 0xE0, 0xFF, 0x3F, 0xF8, 0x00, 0x1F, 0xBF, 0xFC, 0x0F, 0x03,
<       0xC1, 0xE0, 0x1E, 0x01, 0xE0, 0x7F, 0x3F, 0xF8, 0x00, 0x0F, 0xBF, 0xFC, 0x0F, 0x03,
<       0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
<       0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
<       0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E,
<       0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C,
<       0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78,
<       0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0,
<       0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80 };
---
>       0xFF, 0x80, 0x07, 0xF8, 0x00, 0xFE, 0x00, 0x0F, 0xC0, 0x1C, 0x00, 0x70, 0x07, 0x80,
>       0xFF, 0xF0, 0x0F, 0xF8, 0x03, 0xFF, 0x80, 0x7F, 0xF0, 0x1E, 0x00, 0xF0, 0x07, 0x80,
>       0xFF, 0xF8, 0x0F, 0xFC, 0x0F, 0xFF, 0x80, 0xFF, 0xFC, 0x1F, 0x01, 0xF0, 0x0F, 0xC0,
>       0xE0, 0x3C, 0x1F, 0xFC, 0x0F, 0x00, 0x01, 0xE0, 0x1E, 0x1F, 0x03, 0xF0, 0x0F, 0xC0,
>       0xE0, 0x1E, 0x1F, 0xFE, 0x1E, 0x00, 0x01, 0xC0, 0x0E, 0x1F, 0x87, 0xF0, 0x1C, 0xE0,
>       0xE0, 0x0E, 0x3F, 0xFE, 0x1C, 0x00, 0x01, 0xC0, 0x0E, 0x1F, 0xCF, 0x70, 0x1C, 0xE0,
>       0xE0, 0x0E, 0x3F, 0xFF, 0x3C, 0x00, 0x03, 0x80, 0x07, 0x1D, 0xEE, 0x70, 0x38, 0x70,
>       0xE0, 0x0E, 0x7F, 0xFF, 0x38, 0x0F, 0xF3, 0x80, 0x07, 0x1C, 0xFE, 0x70, 0x38, 0x70,
>       0xE0, 0x0E, 0x7F, 0x7F, 0xB8, 0x0F, 0xF3, 0x80, 0x07, 0x1C, 0x7C, 0x70, 0x78, 0x38,
>       0xE0, 0x0E, 0xFF, 0x3F, 0xBC, 0x00, 0x73, 0x80, 0x07, 0x1C, 0x38, 0x70, 0x70, 0x38,
>       0xE0, 0x0E, 0xFE, 0x3F, 0xDC, 0x00, 0x71, 0xC0, 0x0E, 0x1C, 0x10, 0x70, 0x70, 0x1C,
>       0xE0, 0x1D, 0xFE, 0x3F, 0xDE, 0x00, 0xE1, 0xE0, 0x1E, 0x1C, 0x00, 0x70, 0xE0, 0x1C,
>       0xE0, 0x7D, 0xFC, 0x1F, 0xEF, 0x81, 0xE0, 0xF0, 0x3C, 0x1C, 0x00, 0x70, 0xE0, 0x1E,
>       0xFF, 0xFB, 0xFC, 0x1F, 0xE7, 0xFF, 0xC0, 0x7F, 0xF8, 0x1C, 0x00, 0x71, 0xCF, 0xFE,
>       0xFF, 0xE3, 0xFC, 0x0F, 0xE3, 0xFF, 0x80, 0x3F, 0xF0, 0x1C, 0x00, 0x71, 0xCF, 0xFF,
>       0xFC, 0x03, 0xF8, 0x0F, 0xF0, 0x7C, 0x00, 0x07, 0x80, 0x1C, 0x00, 0x71, 0x8F, 0xFF,
>       0x00, 0x07, 0xF8, 0x07, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
>       0x00, 0x07, 0xF0, 0x07, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
>       0x00, 0x0F, 0xF0, 0x03, 0xF8, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
>       0x00, 0x0F, 0xE0, 0x03, 0xFC, 0x00, 0x13, 0x80, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF,
>       0x00, 0x1F, 0xE0, 0x01, 0xFC, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF,
>       0x00, 0x0F, 0xC0, 0x01, 0xFE, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
>       0x00, 0x0F, 0xC0, 0x00, 0xFE, 0x00, 0x94, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x7F,
>       0x00, 0x07, 0x80, 0x00, 0xFF, 0x01, 0xE4, 0x1E, 0x78, 0x00, 0x00, 0x0C, 0xC0, 0x3F,
>       0x00, 0x03, 0x80, 0x00, 0x7F, 0x00, 0x04, 0x3F, 0xFC, 0x00, 0x00, 0x0C, 0xC0, 0x1F,
>       0x00, 0x03, 0x00, 0x00, 0x7F, 0x80, 0xF4, 0x73, 0xCE, 0x08, 0x03, 0x0C, 0x01, 0x8F,
>       0x00, 0xC1, 0x00, 0x00, 0x3F, 0x81, 0x54, 0x61, 0x86, 0x3E, 0x0F, 0xCC, 0xC7, 0xE7,
>       0x00, 0xE0, 0x00, 0x00, 0x3F, 0xC0, 0x54, 0x61, 0x86, 0x7F, 0x1F, 0xCC, 0xCF, 0xF3,
>       0x01, 0xE0, 0x00, 0x00, 0x1F, 0xC0, 0x24, 0x61, 0x86, 0xE3, 0x9C, 0xEC, 0xCE, 0x71,
>       0x00, 0xF0, 0x00, 0x00, 0x1F, 0xE0, 0x84, 0x61, 0x86, 0xC1, 0x98, 0x6C, 0xCC, 0x31,
>       0x00, 0x78, 0x00, 0x00, 0x0F, 0xE1, 0x54, 0x61, 0x86, 0xC1, 0x98, 0x0C, 0xCC, 0x31,
>       0x00, 0x7C, 0x00, 0x00, 0x0F, 0xF1, 0x54, 0x61, 0x86, 0xC1, 0x98, 0x0C, 0xCC, 0x31,
>       0x00, 0x78, 0x3F, 0xFF, 0xFF, 0xF0, 0xF4, 0x61, 0x86, 0xE1, 0x98, 0x0C, 0xCC, 0x31,
>       0x00, 0x78, 0x7F, 0xFF, 0xFF, 0xFA, 0x04, 0x61, 0x86, 0x7D, 0xF8, 0x0E, 0xFC, 0x31,
>       0x00, 0xF0, 0x7F, 0xFF, 0xFF, 0xFA, 0x84, 0x61, 0x86, 0x1D, 0xF8, 0x06, 0xFC, 0x33,
>       0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFD, 0xF6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
>       0x01, 0xE0, 0xFF, 0xFF, 0xFF, 0xFC, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E,
>       0x01, 0xE0, 0xFF, 0xFF, 0xFF, 0xFE, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8 };
diff Marlin/dogm_lcd_implementation.h ../DiscoEasy200/dogm_lcd_implementation.h
53a54
> #include "Configuration.h"
58d58
< #include "Configuration.h"
152c152
<   U8GLIB_SSD1306_128X64 u8g(U8G_I2C_OPT_NONE);
---
>   U8GLIB_SSD1306_128X64 u8g(U8G_I2C_OPT_NONE | U8G_I2C_OPT_FAST);
262,264c262,270
<         lcd_setFont(FONT_MENU);
<         #ifndef STRING_SPLASH_LINE2
<           u8g.drawStr(txt1X, u8g.getHeight() - (DOG_CHAR_HEIGHT), STRING_SPLASH_LINE1);
---
>
>         #ifdef DOGM_LCD_MODIF_BY_DUMNAC
>           //Message Bienvenue
>           u8g.setFont(u8g_font_6x10);
>           u8g.drawStr(73,10,"MARLIN");
>           u8g.drawStr(65,19,"v1.1.0 RC6");
>
>           u8g.setFont(u8g_font_5x8);
>           u8g.drawStr(73,60,"oled by Dum.");
266,268c272,279
<           int txt2X = (u8g.getWidth() - (sizeof(STRING_SPLASH_LINE2) - 1) * (DOG_CHAR_WIDTH)) / 2;
<           u8g.drawStr(txt1X, u8g.getHeight() - (DOG_CHAR_HEIGHT) * 3 / 2, STRING_SPLASH_LINE1);
<           u8g.drawStr(txt2X, u8g.getHeight() - (DOG_CHAR_HEIGHT) * 1 / 2, STRING_SPLASH_LINE2);
---
>           lcd_setFont(FONT_MENU);
>           #ifndef STRING_SPLASH_LINE2
>             u8g.drawStr(txt1X, u8g.getHeight() - (DOG_CHAR_HEIGHT), STRING_SPLASH_LINE1);
>           #else
>             int txt2X = (u8g.getWidth() - (sizeof(STRING_SPLASH_LINE2) - 1) * (DOG_CHAR_WIDTH)) / 2;
>             u8g.drawStr(txt1X, u8g.getHeight() - (DOG_CHAR_HEIGHT) * 3 / 2, STRING_SPLASH_LINE1);
>             u8g.drawStr(txt2X, u8g.getHeight() - (DOG_CHAR_HEIGHT) * 1 / 2, STRING_SPLASH_LINE2);
>           #endif
Les sous-répertoires Marlin/example_configurations et ../DiscoEasy200/example_configurations sont identiques
Les sous-répertoires Marlin/fonts et ../DiscoEasy200/fonts sont identiques
Seulement dans ../DiscoEasy200/: .gcc-flags.json
Seulement dans ../DiscoEasy200/: .git
Seulement dans ../DiscoEasy200/: .gitignore
diff Marlin/language_fr.h ../DiscoEasy200/language_fr.h
41a42,49
> #define MSG_LCD_OK                          "OK"
> #define MSG_PINCH                           "Pincez la feuille"
> #define MSG_SET_OFFSET                      "en reglant l'offset"
> #define MSG_VALIDATE                        "puis validez"
> #define MSG_ADD_SHEET                       "Glissez une feuille"
> #define MSG_BESIDE_NOZZLE                   "en dessous de la buse"
> #define MSG_CLICK_OK                        "puis appuyez sur OK"
> #define MSG_PARALLEL_X                      "Parrallel X"
67a76
> #define MSG_Z_OFFSET                        "Regl. Z Offset"
122a132
> #define MSG_PREPARE_ADVENCED                "Options avancees"
130a141,146
> #ifdef MSG_WAIT
>   #undef MSG_WAIT
>   #define MSG_WAIT                          "   Patientez..."
> #endif
> #define MSG_PARAMETERS                      "   Parametres"
> #define MSG_SAVED                           "   Sauvegardes"
diff Marlin/language.h ../DiscoEasy200/language.h
128c128,132
< #define MSG_M115_REPORT                     "FIRMWARE_NAME:Marlin " DETAILED_BUILD_VERSION " SOURCE_CODE_URL:" SOURCE_CODE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) " UUID:" MACHINE_UUID "\n"
---
> #ifndef BUILD_CODE
>   #define MSG_M115_REPORT                     "FIRMWARE_NAME:Marlin " DETAILED_BUILD_VERSION " SOURCE_CODE_URL:" SOURCE_CODE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) " UUID:" MACHINE_UUID "\n"
> #else
>   #define MSG_M115_REPORT                     "UUID:" MACHINE_UUID " BUILD_CODE:" BUILD_CODE "\n"
> #endif
Seulement dans ../DiscoEasy200/: lib
diff Marlin/Marlin.h ../DiscoEasy200/Marlin.h
252a253,254
> bool enqueued_commands_finished__CALLABLE_FROM_LCD_ONLY(); // DAGO-Dev
> void wait_all_commands_finished__CALLABLE_FROM_LCD_ONLY(); // DAGO-Dev
diff Marlin/Marlin_main.cpp ../DiscoEasy200/Marlin_main.cpp
83a84,87
> #if ENABLED(USE_SECOND_SERIAL)
>   #include "HardwareSerial.h"
> #endif
>
233a238,248
>  * ************ DAGOMA.FR Specific - This can change to suit future G-code regulations
>  * M700 - Wifi : Set SSID to use.
>  * M701 - Wifi : Set Password to use and connect !
>  * M702 - Wifi : Get current local IP Address if wifi is ready, 0 otherwize.
>  * M710 - Wifi : Set printer technical name.
>  * M711 - Wifi : Set API Url to use.
>  * M712 - Wifi : Set API Key to use.
>  * M720 - Wifi : Echo the string in serial .
>
>  * ************ DAGOMA.FR End ***************
>  *
245a261
>
328a345,348
> #if ENABLED(IS_MONO_FAN) || ENABLED(PRINTER_HEAD_EASY)
> static millis_t next_fan_auto_regulation_check = 0;
> #endif
>
404a425,426
>   #define SIN_30 COS_60
>   #define COS_30 SIN_60
426a449,457
>
>   #if ENABLED( DELTA_EXTRA )
>     bool postcompute_tri_ready = false;
>     bool startup_auto_calibration = false;
>     float z_smooth_tri_leveling_height = 0.0;
>     #if ENABLED( SDSUPPORT )
>       inline void abort_sd_printing();
>     #endif
>   #endif
449a481,493
>   const millis_t FRS_DEBOUNCE_DELAY = 250UL; // filament runout sensor delay
>   static millis_t frs_debounce_time = 0UL; // filament runout sensor debouncing count
> #endif
> #if ENABLED(SUMMON_PRINT_PAUSE)
>   static bool print_pause_summoned = false;
>   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
>     static bool filrunout_bypassed = false;
>   #endif
> #endif
> #if ENABLED(U8GLIB_SSD1306) && ENABLED(INTELLIGENT_LCD_REFRESH_RATE)
>   static float last_intelligent_z_lcd_update = 0;
>   static float last_intelligent_F_lcd_update = 0;
>   static bool last_intelligent_F_authorized_lcd_update = false;
588a633,655
>  * Test for all enqueued commands to be processed.
>  * return false if it remains command, true when all commands are done
>  */
> bool enqueued_commands_finished__CALLABLE_FROM_LCD_ONLY() {
>   if ( commands_in_queue > 0) {
>     process_next_command();
>     cmd_queue_index_r = (cmd_queue_index_r + 1) % BUFSIZE;
>     commands_in_queue--;
>     return false;
>   }
>   return true;
> }
>
> /**
>  * Wait for all enqueued commands to be processed.
>  */
> void wait_all_commands_finished__CALLABLE_FROM_LCD_ONLY() {
>   while (!enqueued_commands_finished__CALLABLE_FROM_LCD_ONLY()) {
>     idle();
>   }
> }
>
> /**
737a805,814
> #if ENABLED( ONE_LED )
>   inline void one_led_on() {
>     digitalWrite( ONE_LED_PIN, true ^ ONE_LED_INVERTING );
>   }
>
>   inline void one_led_off() {
>     digitalWrite( ONE_LED_PIN, false ^ ONE_LED_INVERTING );
>   }
> #endif
>
857a935,984
>
>   #if ENABLED(USE_SECOND_SERIAL)
>     SECOND_SERIAL.begin( SECOND_SERIAL_BAUDRATE );
>   #endif
>
>   #if ENABLED(SUMMON_PRINT_PAUSE) && SUMMON_PRINT_PAUSE_PIN != X_MIN_PIN && SUMMON_PRINT_PAUSE_PIN != Y_MAX_PIN && SUMMON_PRINT_PAUSE_PIN != Z_MIN_PIN
>     SET_INPUT(SUMMON_PRINT_PAUSE_PIN);
>     WRITE(SUMMON_PRINT_PAUSE_PIN, HIGH);
>
>     #if ENABLED(FILAMENT_RUNOUT_SENSOR)
>       delay( 100 );
>       if ( READ( SUMMON_PRINT_PAUSE_PIN ) ^ SUMMON_PRINT_PAUSE_INVERTING ) {
>           filrunout_bypassed = true;
>           SERIAL_ECHOLN( PSTR("Filament sensor bypassed") );
>       }
>     #endif
>   #elif ENABLED(ONE_BUTTON)
>     SET_INPUT(ONE_BUTTON_PIN);
>     WRITE(ONE_BUTTON_PIN, HIGH);
>   #endif
>
>   #if ENABLED(PRINTER_HEAD_EASY)
>     SET_OUTPUT(PRINTER_HEAD_EASY_CONSTANT_FAN_PIN);
>     WRITE(PRINTER_HEAD_EASY_CONSTANT_FAN_PIN, LOW);
>   #endif
>
>   #if ENABLED( DELTA_EXTRA )
>     #if ENABLED( ONE_BUTTON )
>       // Read the button state here
>       millis_t now = millis();
>       millis_t timeout = now + 2500UL;
>       do {
>          now = millis();
>          delay( 100 );
>       } while( ( READ( SUMMON_PRINT_PAUSE_PIN ) ^ SUMMON_PRINT_PAUSE_INVERTING ) && PENDING( now, timeout ) );
>       if ( ELAPSED( now, timeout ) ) {
>         startup_auto_calibration = true;
>         enqueue_and_echo_commands_P( PSTR("D851") );
>       }
>       else {
>         enqueue_and_echo_commands_P( PSTR("G28\nM106 S255") );
>       }
>     #endif
>   #endif
>
>   #if ENABLED( ONE_LED )
>     pinMode( ONE_LED_PIN, OUTPUT );
>     one_led_off();
>   #endif
>
859a987,1036
> #if ENABLED(WIFI_PRINT)
>   unsigned long last_status_timestamp = 0;
>   void manage_second_serial_status() {
>     if ( millis() - last_status_timestamp > 10000 ) {
>       SECOND_SERIAL.print( "STAT:" );
>
>       SECOND_SERIAL.print( "tstp:" );
>       SECOND_SERIAL.print(  millis()  );
>
>       SECOND_SERIAL.print( " X:" );
>       SECOND_SERIAL.print( current_position[X_AXIS] );
>       SECOND_SERIAL.print( " Y:" );
>       SECOND_SERIAL.print( current_position[Y_AXIS] );
>       SECOND_SERIAL.print( " Z:" );
>       SECOND_SERIAL.print( current_position[Z_AXIS] );
>       SECOND_SERIAL.print( " E:" );
>       SECOND_SERIAL.print( current_position[E_AXIS] );
>
>       #if HAS_TEMP_HOTEND
>         SECOND_SERIAL.print( " TC:" );
>         SECOND_SERIAL.print( degHotend(target_extruder), 1 );
>         SECOND_SERIAL.print( " TT:" );
>         SECOND_SERIAL.print( degTargetHotend(target_extruder), 1 );
>       #endif
>       #if HAS_TEMP_BED
>         SECOND_SERIAL.print( " BC:" );
>         SECOND_SERIAL.print( degBed(), 1 );
>         SECOND_SERIAL.print( " BT:" );
>         SECOND_SERIAL.print( degTargetBed(), 1 );
>       #endif
>
>       #if ENABLED(SDSUPPORT)
>         SECOND_SERIAL.print( " SD_OK:" );
>         SECOND_SERIAL.print( card.cardOK );
>
>         SECOND_SERIAL.print( " SD_PRINTING:" );
>         SECOND_SERIAL.print( card.sdprinting );
>
>         SECOND_SERIAL.print( " SD_PROGRESS:" );
>         SECOND_SERIAL.print( card.percentDone() );
>       #endif
>
>       SECOND_SERIAL.println();
>
>       last_status_timestamp = millis();
>     }
>   }
>
> #endif // END WIFI_PRINT
>
870a1048,1052
>
>   #if ENABLED( WIFI_PRINT )
>     manage_second_serial_status();
>   #endif
>
873c1055
<   #if ENABLED(SDSUPPORT)
---
>   #if ENABLED(SDSUPPORT) && DISABLED(ONE_BUTTON)
940a1123,1136
>   #if ENABLED( WIFI_PRINT )
>
>     while (commands_in_queue < BUFSIZE && (MYSERIAL.available() > 0 || SECOND_SERIAL.available() > 0 )) {
>
>     char serial_char;
>     if ( SECOND_SERIAL.available() > 0 ) {
>       serial_char = SECOND_SERIAL.read();
>     }
>     else {
>       serial_char = MYSERIAL.read();
>     }
>
>   #else // ELSE WIFI_PRINT
>
944a1141,1142
>   #endif // END WIFI_PRINT
>
962a1161,1168
>       #if ENABLED( WIFI_PRINT )
>         if ( strncmp( command, "REDY:", 4 ) == 0 ) {
>           // Do stuff with that ?
>           lcd_setstatus( command + 5 );
>           continue;
>         }
>       #endif // END WIFI_PRINT
>
975a1182,1186
>
>           #if ENABLED( WIFI_PRINT )
>             SECOND_SERIAL.println( 'K' );
>           #endif
>
984a1196,1200
>
>             #if ENABLED( WIFI_PRINT )
>               SECOND_SERIAL.println( 'K' );
>             #endif
>
990a1207,1211
>
>           #if ENABLED( WIFI_PRINT )
>             SECOND_SERIAL.println( 'K' );
>           #endif
>
998a1220,1224
>
>         #if ENABLED( WIFI_PRINT )
>           SECOND_SERIAL.println( 'K' );
>         #endif
>
1027a1254,1257
>
>       #if ENABLED( WIFI_PRINT )
>         SECOND_SERIAL.println( 'O' );
>       #endif
1033a1264,1273
>       #if ENABLED(WIFI_PRINT)
>       if (MYSERIAL.available() > 0 || SECOND_SERIAL.available() > 0) {
>         // if we have one more character, copy it over
>         if (SECOND_SERIAL.available() > 0) {
>           serial_char = SECOND_SERIAL.read();
>         }
>         else {
>           serial_char = MYSERIAL.read();
>         }
>       #else
1036a1277
>       #endif
1074c1315,1320
<           || ((sd_char == '#' || sd_char == ':') && !sd_comment_mode)
---
>           || ((sd_char == '#'
>              #if DISABLED(WIFI_PRINT)
>              || sd_char == ':'
>              #endif
>              ) && !sd_comment_mode)
>
1075a1322,1332
>         if (sd_char == '#') stop_buffering = true;
>
>         sd_comment_mode = false; //for new command
>
>         if (sd_count) {
>           command_queue[cmd_queue_index_w][sd_count] = '\0'; //terminate string
>           sd_count = 0; //clear buffer
>
>           _commit_command(false);
>         }
>
1086a1344
>           #if DISABLED(ONE_BUTTON)
1087a1346
>           #endif
1089,1091d1347
<         if (sd_char == '#') stop_buffering = true;
<
<         sd_comment_mode = false; //for new command
1094,1098d1349
<
<         command_queue[cmd_queue_index_w][sd_count] = '\0'; //terminate string
<         sd_count = 0; //clear buffer
<
<         _commit_command(false);
1537c1788,1818
<   static void run_z_probe() {
---
>   // Check if pause is triggered during G29 (manuel bed leveling) and D851 (custom calibration)
>   #if ENABLED(EMERGENCY_STOP)
>     void handle_emergency_stop(){
>       if ( trigger_emergency_stop ) {
>         // Abort current operations:
>         // - Move the nozzle up
>         #if ENABLED(EMERGENCY_STOP_Z_MOVE)
>           // Setting the current_position seems useless as the move is stopped by resetting...?
>           //current_position[Z_AXIS] += 5;
>           feedrate = homing_feedrate[Z_AXIS];
>           #if ENABLED(DELTA)
>             calculate_delta(current_position);
>             plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS], feedrate / 60, active_extruder);
>           #else
>             line_to_current_position();
>           #endif
>         #endif
>         // - Reset the board
>         while( true ) {
>           #if ENABLED(ONE_LED)
>             one_led_on();
>             delay(150);
>             one_led_off();
>           #endif
>           delay(150);
>         }
>       }
>     }
>   #endif
>
>   static void run_z_probe(bool fast=false) {
1555,1556c1836,1846
<       feedrate = homing_feedrate[Z_AXIS] / 4;
<       destination[Z_AXIS] = -10;
---
>       #if ENABLED(DELTA_EXTRA)
>         if (fast) {
>           feedrate = homing_feedrate[Z_AXIS] / 2;
>         }
>         else {
>       #endif
>           feedrate = homing_feedrate[Z_AXIS] / 4;
>       #if ENABLED(DELTA_EXTRA)
>         }
>       #endif
>       destination[Z_AXIS] = -20;
1558a1849,1851
>       #if ENABLED(EMERGENCY_STOP)
>         handle_emergency_stop();
>       #endif
1575a1869,1871
>       #if ENABLED(DEBUG_LEVELING_FEATURE)
>         SERIAL_ECHOLN("run_z_probe (DISCO)");
>       #endif
1583a1880,1882
>       #if ENABLED(EMERGENCY_STOP)
>         handle_emergency_stop();
>       #endif
1595a1895,1897
>       #if ENABLED(EMERGENCY_STOP)
>         handle_emergency_stop();
>       #endif
1603a1906,1908
>       #if ENABLED(EMERGENCY_STOP)
>         handle_emergency_stop();
>       #endif
3075a3381,3859
>   #if ENABLED( DELTA_EXTRA )
>
>     #define PROBE_POINT_NUMBER 19 // 12 outer, 6 inner, 1 center
>     // Numbered from X tower cardinal axis,
>     // from outside to center
>     // Contains constant X,Y probe point,
>     // thrid and last float room will contain probed altitude
>     float probe_plan[PROBE_POINT_NUMBER][3] = {
>       // Outer
>       {
>         delta_tower1_x,
>         delta_tower1_y,
>         0.0
>       },
>       {
>         -COS_60 * delta_radius,
>         -SIN_60 * delta_radius,
>         0.0
>       },
>       {
>         0.0,
>         -1.0 * delta_radius,
>         0.0
>       },
>       {
>         COS_60 * delta_radius,
>         -SIN_60 * delta_radius,
>         0.0
>       },
>       {
>         delta_tower2_x,
>         delta_tower2_y,
>         0.0
>       },
>       {
>         delta_radius,
>         0.0,
>         0.0
>       },
>       {
>         SIN_60 * delta_radius,
>         COS_60 * delta_radius,
>         0.0
>       },
>       {
>         COS_60 * delta_radius,
>         SIN_60 * delta_radius,
>         0.0
>       },
>       {
>         delta_tower3_x,
>         delta_tower3_y,
>         0.0
>       },
>       {
>         -COS_60 * delta_radius,
>         SIN_60 * delta_radius,
>         0.0
>       },
>       {
>         -SIN_60 * delta_radius,
>         COS_60 * delta_radius,
>         0.0
>       },
>       {
>         -delta_radius,
>         0.0,
>         0.0
>       },
>       // Inner
>       {
>         -SIN_60 * delta_radius / 2.0,
>         -COS_60 * delta_radius / 2.0,
>         0.0
>       },
>       {
>         0.0,
>         -delta_radius / 2.0,
>         0.0
>       },
>       {
>         SIN_60 * delta_radius / 2.0,
>         -COS_60 * delta_radius / 2.0,
>         0.0
>       },
>       {
>         SIN_60 * delta_radius / 2.0,
>         COS_60 * delta_radius / 2.0,
>         0.0
>       },
>       {
>         0.0,
>         delta_radius / 2.0,
>         0.0
>       },
>       {
>         -SIN_60 * delta_radius / 2.0,
>          COS_60 * delta_radius / 2.0,
>         0.0
>       },
>       // Center
>       {
>         0.0,
>         0.0,
>         0.0
>       }
>     };
>
>     // As probe_plan above,
>     // numbered from X tower cardinal axis
>     // From outside to center
>     #define PROBE_MESH_NUMBER 24
>     const short probe_plan_mesh[PROBE_MESH_NUMBER][3] = {
>       // Outer (one side outer) (12)
>       { 0, 1, 12 },
>       { 1, 2, 13 },
>       { 2, 3, 13 },
>       { 3, 4, 14 },
>       { 4, 5, 14 },
>       { 5, 6, 15 },
>       { 7, 6, 15 },
>       { 7, 8, 16 },
>       { 8, 9, 16 },
>       { 9, 10, 17 },
>       { 10, 11, 17 },
>       { 11, 0, 12 },
>       // Outer (one point outer) (6)
>       { 1, 13, 12 },
>       { 3, 14, 13 },
>       { 5, 15, 14 },
>       { 7, 16, 15 },
>       { 9, 17, 16 },
>       { 11, 12, 17 },
>       // Inner (6)
>       { 12, 13, 18 },
>       { 13, 14, 18 },
>       { 14, 15, 18 },
>       { 15, 16, 18 },
>       { 16, 17, 18 },
>       { 17, 12, 18 }
>     };
>
>     // Predefine used functions
>     inline void gcode_M500();
>     inline void gcode_M665();
>     inline void gcode_G30(bool fast=false);
>
>     #define Z_AVG_TOLERANCE 0.02
>
>     inline float get_probed_Z_avg(bool fast=false) {
>
>       bool all_points_are_good = false;
>       float z_read[3] = { 50.0 };
>       float z_avg = 0.0;
>
>       do {
>         gcode_G30(fast);
>
>         z_read[2] = z_read[1];
>         z_read[1] = z_read[0];
>         z_read[0] = current_position[Z_AXIS];
>
>         if (fast) {
>           z_avg = ( z_read[0] + z_read[1] ) / 2.0;
>         }
>         else {
>           z_avg = ( z_read[0] + z_read[1] + z_read[2] ) / 3.0;
>         }
>
>         set_destination_to_current();
>         destination[ Z_AXIS ] = min( 50.0, destination[ Z_AXIS ] + 5.0 );
>         prepare_move();
>         st_synchronize();
>
>         if ( destination[ Z_AXIS ] > 49.90 ) {
>           int i=10; do { idle(true); delay(100); } while(--i);
>           all_points_are_good = false;
>         }
>         else {
>           // Check for all points
>           all_points_are_good =
>             abs(z_read[0] - z_avg) < Z_AVG_TOLERANCE &&
>             abs(z_read[1] - z_avg) < Z_AVG_TOLERANCE &&
>             abs(z_read[2] - z_avg) < Z_AVG_TOLERANCE;
>         }
>
>       } while( !all_points_are_good );
>
>
>       return z_avg;
>     }
>
>     /**
>      *           T3
>      *           |
>      *           |
>      *          4| 3
>      *           |
>      *      ZX   O    YZ
>      *        5      2
>      *
>      *         0    1
>      *
>      *  T1       XY        T2
>      */
>
>     float triangle_sign(const float x, const float y, const short p1, const short p2) {
>       return
>         (x - probe_plan[p2][0]) * (probe_plan[p1][1] - probe_plan[p2][1]) -
>         (probe_plan[p1][0] - probe_plan[p2][0]) * (y - probe_plan[p2][1]);
>     }
>
>     bool triangle_contains(const float x, const float y, const short t) {
>       bool b1, b2, b3;
>
>       const short *triangle;
>       triangle = probe_plan_mesh[t];
>
>       b1 = triangle_sign(x, y, triangle[0], triangle[1]) <= 0.0;
>       b2 = triangle_sign(x, y, triangle[1], triangle[2]) <= 0.0;
>       b3 = triangle_sign(x, y, triangle[2], triangle[0]) <= 0.0;
>
>       return ((b1 == b2) && (b2 == b3));
>     }
>
>     #define PROBE_REGION_NUMBER 12
>     const short probe_plan_triangle_mesh_region[PROBE_REGION_NUMBER][4] = {
>       { 18, 12, 0 },
>       { 18, 12, 1 },
>       { 19, 13, 2 },
>       { 19, 13, 3 },
>       { 20, 14, 4 },
>       { 20, 14, 5 },
>       { 21, 15, 6 },
>       { 21, 15, 7 },
>       { 22, 16, 8 },
>       { 22, 16, 9 },
>       { 23, 17, 10 },
>       { 23, 17, 11 }
>     };
>
>     // TODO: Move it to the right place
>     // WHERE: on calculate_delta parameters ?
>     // 'CAUSE: these values are fixed against delta R
>     float precalc_probe_plan_region_aref[8] = { 0.0 };
>
>     inline short triangle_index_in_region( const float x, const float y, const short r ) {
>       const short *region;
>       region = probe_plan_triangle_mesh_region[r];
>
>       if ( triangle_contains(x, y, region[0]) ) return region[0];
>       if ( triangle_contains(x, y, region[1]) ) return region[1];
>
>       return region[2];
>     };
>
>     inline short region_index( const float x, const float y ) {
>
>       // While all tri equations are just: y = a.x;
>       float aTested = y / x;
>
>       // Simple test to choice between 2 region groups: 2,3,4,5,6,7 or 8,9,10,11,0,1
>       if ( x >= 0.0 ) {
>         // Region is one of 2,3,4,5,6,7
>
>         // Simple test to choice between 2 sub region groups: 5,6,7 or 2,3,4
>         if (y >= 0.0 ) {
>           // Region is one of 5,6,7
>           if ( aTested > precalc_probe_plan_region_aref[4] ) {
>             // Region is one of 6, 7
>             if ( aTested > precalc_probe_plan_region_aref[5] ) {
>               return 7;
>             }
>             else {
>               return 6;
>             }
>           }
>           else {
>             return 5;
>           }
>         }
>         else {
>           // Region is one of 2,3,4
>           if ( aTested > precalc_probe_plan_region_aref[2] ) {
>             // Region is one of 3,4
>             if ( aTested > precalc_probe_plan_region_aref[3] ) {
>               return 4;
>             }
>             else {
>               return 3;
>             }
>           }
>           else {
>             return 2;
>           }
>         }
>       }
>       else {
>         // Region is one of 8,9,10,11,0,1
>
>         // Simple test to choice between 2 sub region groups: 8,9,10 or 11,0,1
>         if (y >= 0.0 ) {
>           // Region is one of 8,9,10
>           if ( aTested > precalc_probe_plan_region_aref[6] ) {
>             // Region is one of 9,10
>             if ( aTested > precalc_probe_plan_region_aref[7] ) {
>               return 10;
>             }
>             else {
>               return 9;
>             }
>           }
>           else {
>             return 8;
>           }
>         }
>         else {
>           // Region is one of 11,0,1
>           if ( aTested > precalc_probe_plan_region_aref[0] ) {
>             // Region is one of 0,1
>             if ( aTested > precalc_probe_plan_region_aref[1] ) {
>               return 1;
>             }
>             else {
>               return 0;
>             }
>           }
>           else {
>             return 11;
>           }
>         }
>       }
>
>       // At this point, it's an error
>       // but do not mess up print with 'index out of bound'
>       return 0;
>     }
>
>     inline short triangle_index( const float x, const float y ) {
>       short r = region_index( x, y );
>       return triangle_index_in_region( x, y, r );
>     }
>
>     float probed_tri_postcompute_a[PROBE_MESH_NUMBER] = { 0.0 };
>     float probed_tri_postcompute_b[PROBE_MESH_NUMBER] = { 0.0 };
>     float probed_tri_postcompute_c[PROBE_MESH_NUMBER] = { 0.0 };
>     float probed_tri_postcompute_d[PROBE_MESH_NUMBER] = { 0.0 };
>
>     inline void probing_postcompute_tri_parameters() {
>
>
>       // Plane equation: a.x+b.y+c.z+d = 0
>       // Query to find z for given x,y will be
>       // z = (-d - b.y - a.x ) / c;
>       // z = -d/c - b.y/c - a.x/c;
>       // z = - (d + b.y + a.x) / c ;
>       // z = - (L/c + M/c + N/c);
>       // if
>       //   L = d/c
>       //   M = b/c
>       //   N = a/c
>
>
>       //   C
>       //   ^
>       // AC|
>       //   |
>       //   A ----> B
>       //      AB
>
>       float *A;
>       float *B;
>       float *C;
>
>       #define X 0
>       #define Y 1
>       #define Z 2
>
>       int i;
>       for(i=0; i < PROBE_MESH_NUMBER; i++) {
>         A = probe_plan[probe_plan_mesh[i][0]];
>         B = probe_plan[probe_plan_mesh[i][1]];
>         C = probe_plan[probe_plan_mesh[i][2]];
>         float a = ( B[Y]-A[Y] )*( C[Z]-A[Z] ) - ( C[Y]-A[Y] )*( B[Z]-A[Z] );
>         float b = ( B[Z]-A[Z] )*( C[X]-A[X] ) - ( C[Z]-A[Z] )*( B[X]-A[X] );
>         float c = ( B[X]-A[X] )*( C[Y]-A[Y] ) - ( C[X]-A[X] )*( B[Y]-A[Y] );
>         float d = -(a*A[X]+b*A[Y]+c*A[Z]);
>
>         float l = d/c;
>         float m = b/c;
>         float n = a/c;
>
>         probed_tri_postcompute_a[i] = a;
>         probed_tri_postcompute_b[i] = b;
>         probed_tri_postcompute_c[i] = c;
>         probed_tri_postcompute_d[i] = d;
>
>       }
>
>       // For memory:
>       // precalc_probed_tri_aref[ 0 ] = delta_tower2_y / delta_tower2_x;
>       // precalc_probed_tri_aref[ 1 ] = probe_point_YZ_y / probe_point_YZ_x;
>       // precalc_probed_tri_aref[ 2 ] = delta_tower1_y / delta_tower1_x;
>       // precalc_probed_tri_aref[ 3 ] = probe_point_ZX_y / probe_point_ZX_x;
>
>       precalc_probe_plan_region_aref[ 0 ] = probe_plan[ 0][1] / probe_plan[ 0][0];
>       precalc_probe_plan_region_aref[ 1 ] = probe_plan[ 1][1] / probe_plan[ 1][0];
>       precalc_probe_plan_region_aref[ 2 ] = probe_plan[ 3][1] / probe_plan[ 3][0];
>       precalc_probe_plan_region_aref[ 3 ] = probe_plan[ 4][1] / probe_plan[ 4][0];
>       precalc_probe_plan_region_aref[ 4 ] = probe_plan[ 6][1] / probe_plan[ 6][0];
>       precalc_probe_plan_region_aref[ 5 ] = probe_plan[ 7][1] / probe_plan[ 7][0];
>       precalc_probe_plan_region_aref[ 6 ] = probe_plan[ 9][1] / probe_plan[ 9][0];
>       precalc_probe_plan_region_aref[ 7 ] = probe_plan[10][1] / probe_plan[10][0];
>
>       postcompute_tri_ready = true;
>     }
>
>     inline void gcode_G29() {
>
>       postcompute_tri_ready = false;
>
>       gcode_G28();
>
>       feedrate = homing_feedrate[ X_AXIS ];
>
>       int i;
>       // Reset
>       for(i=0; i<PROBE_POINT_NUMBER; i++) {
>         probe_plan[i][2] = 42.0;
>       }
>
>       // Probing
>       for(i=0; i<PROBE_POINT_NUMBER; i++) {
>         destination[ X_AXIS ] = probe_plan[i][0];
>         destination[ Y_AXIS ] = probe_plan[i][1];
>         destination[ Z_AXIS ] = 10.0;
>         prepare_move();
>         st_synchronize();
>         probe_plan[i][2] = get_probed_Z_avg();
>       }
>
>       #if ENABLED(DEBUG_LEVELING_FEATURE)
>         if (DEBUGGING(LEVELING)) {
>           SERIAL_ECHOLNPGM("Probed tri altitude:");
>           for(i=0; i<PROBE_POINT_NUMBER; i++) {
>             SERIAL_ECHOPGM("               [" );
>             if(i<10) SERIAL_ECHOPGM( "0" );
>             SERIAL_ECHO( i );
>             SERIAL_ECHOPGM("]: ");
>             SERIAL_ECHOLN( probe_plan[i][2] );
>           }
>         }
>       #endif
>
>       z_smooth_tri_leveling_height = 20.0;
>
>       probing_postcompute_tri_parameters();
>
>
>       //#define TEST_SPECIAL_PROBE
>       #ifdef TEST_SPECIAL_PROBE
>
>         for( float y=-100.0; y < 100.0; y+= 10.0 ) {
>           for( float x=-100.0; x < 100.0; x+= 10.0 ) {
>             SERIAL_ECHO( "  @X:" );
>             SERIAL_ECHO( x );
>             SERIAL_ECHO( " Y:" );
>             SERIAL_ECHO( y );
>             SERIAL_ECHO( "  triangle_index:" );
>             SERIAL_ECHOLN( triangle_index( x, y ) );
>           }
>         }
>
>       #endif
>
>     }
>
>   #else // ELSE: !DELTA_EXTRA
>
3237a4022,4024
>     #if ENABLED(EMERGENCY_STOP)
>       handle_emergency_stop();
>     #endif
3601a4389,4390
>   #endif // END !DELTA_EXTRA
>
3606a4396,4398
>     #if ENABLED(DELTA_EXTRA)
>     inline void gcode_G30(bool fast/*default is declared above*/) {
>     #else
3607a4400
>     #endif
3619c4412,4416
<       run_z_probe();
---
>       #if ENABLED(DELTA_EXTRA)
>         run_z_probe(fast);
>       #else
>         run_z_probe();
>       #endif
3627a4425
>
3630a4429,4431
>         #if ENABLED(Z_DUAL_ENDSTOPS)
>           z_probed_value_before_z_raise = current_position[Z_AXIS];
>         #endif
5994a6796,6797
>
>
5996a6800,6891
>   // Generally :
>   //   homing_feedrate is expressed in mm/min
>   //   max_feedrate is expressed in mm/s
>   #if ENABLED(DELTA)
>     #define SET_FEEDRATE_FOR_MOVE          feedrate = homing_feedrate[X_AXIS] / 60.0;
>     #define SET_FEEDRATE_FOR_EXTRUDER_MOVE feedrate = max_feedrate[E_AXIS];
>     // The following plan method use feedrate expressed in mm/s
>     #define RUNPLAN calculate_delta(destination); \
>                     plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], destination[E_AXIS], feedrate, active_extruder);
>   #else
>     #define SET_FEEDRATE_FOR_MOVE          feedrate = homing_feedrate[X_AXIS];
>     #define SET_FEEDRATE_FOR_EXTRUDER_MOVE feedrate = max_feedrate[E_AXIS] * 60.0;
>     // The following plan method use feedrate expressed in mm/min
>     #define RUNPLAN line_to_destination(feedrate);
>   #endif
>
>   #if ENABLED(DELTA_EXTRA) && ENABLED(Z_MIN_MAGIC)
>
>     bool change_filament_by_tap_tap = false;
>
>     inline void manage_tap_tap() {
>       if ( !startup_auto_calibration
>         && !IS_SD_PRINTING
>         && !change_filament_by_tap_tap
>         #if ENABLED(SUMMON_PRINT_PAUSE)
>         && !print_pause_summoned
>         #endif
>         #if ENABLED(FILAMENT_RUNOUT_SENSOR)
>         && !filament_ran_out
>         #endif
>         && z_magic_hit_count > 1
>       ) {
>         SERIAL_ECHOLNPGM("Tap tap : Heating and changing filament from IDLE state");
>         change_filament_by_tap_tap = true;
>         enqueue_and_echo_commands_P(PSTR("G28\nM104 S180\nG0 F150 X0 Y0 Z100\nM109 S180\nD600\nM106 S255\nM104 S0\nG28"));
>       }
>     }
>
>     inline bool cant_enter_M600_or_D600();
>
>     inline void gcode_D600() {
>       SERIAL_ECHOLNPGM( "Filament expulsion" );
>
>       if (cant_enter_M600_or_D600()) return;
>
>       // Synchronize all moves
>       st_synchronize();
>
>       float previous_dest = destination[E_AXIS];
>       destination[E_AXIS] += FILAMENTCHANGE_FINALRETRACT;
>
>       SET_FEEDRATE_FOR_EXTRUDER_MOVE;
>       RUNPLAN;
>       st_synchronize();
>       destination[E_AXIS] = previous_dest;
>       current_position[E_AXIS] = destination[E_AXIS];
>       sync_plan_position_e();
>
>       change_filament_by_tap_tap = false;
>     }
>   #endif
>
>
>   inline bool cant_enter_M600_or_D600() {
>
>     if (degHotend(active_extruder) < extrude_min_temp) {
>       SERIAL_ERROR_START;
>       SERIAL_ERRORLNPGM(MSG_TOO_COLD_FOR_M600);
>
>       #if ENABLED(FILAMENT_RUNOUT_SENSOR)
>         filament_ran_out = false;
>       #endif
>
>       #if ENABLED(SUMMON_PRINT_PAUSE)
>         print_pause_summoned = false;
>       #endif
>
>       #if ENABLED(DELTA_EXTRA) && ENABLED(Z_MIN_MAGIC)
>         change_filament_by_tap_tap = false;
>       #endif
>
>       return true;
>     }
>
>     return false;
>   }
>
>   #if ENABLED(ONE_LED)
>     // Pre-declaration
>     inline void set_notify_warning();
>   #endif
>
6004a6900,6902
>    *  P[pin]      - Pin to wait for, if not specified use lcd button
>    *              - Pin can be A, B or C respectively for X, Y and Z endstops.
>    *  S[0|1]      - If Pin, state to wait for, if not specified use LOW
6011,6015c6909
<     if (degHotend(active_extruder) < extrude_min_temp) {
<       SERIAL_ERROR_START;
<       SERIAL_ERRORLNPGM(MSG_TOO_COLD_FOR_M600);
<       return;
<     }
---
>     SERIAL_ECHOLNPGM( "Pause for filament change" );
6017,6019c6911,6915
<     float lastpos[NUM_AXIS];
<     #if ENABLED(DELTA)
<       float fr60 = feedrate / 60;
---
>     if (cant_enter_M600_or_D600()) return;
>
>     #if ENABLED(SUMMON_PRINT_PAUSE)
>       // Simulate direct call M600
>       print_pause_summoned = true;
6021a6918,6920
>     float lastpos[NUM_AXIS];
>     float previous_feedrate;
>
6025,6030c6924,6927
<     #if ENABLED(DELTA)
<       #define RUNPLAN calculate_delta(destination); \
<                       plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], destination[E_AXIS], fr60, active_extruder);
<     #else
<       #define RUNPLAN line_to_destination();
<     #endif
---
>     previous_feedrate = feedrate;
>
>     //finish moves
>     // st_synchronize();
6037a6935
>     SET_FEEDRATE_FOR_EXTRUDER_MOVE;
6041,6043c6939,6953
<     if (code_seen('Z')) destination[Z_AXIS] += code_value();
<     #ifdef FILAMENTCHANGE_ZADD
<       else destination[Z_AXIS] += FILAMENTCHANGE_ZADD;
---
>     #if ENABLED(DELTA_EXTRA)
>       float z_destination = destination[Z_AXIS];
>       if (code_seen('Z')) z_destination += code_value();
>       #ifdef FILAMENTCHANGE_ZADD
>         else z_destination += FILAMENTCHANGE_ZADD;
>       #endif
>       NOMORE(z_destination, (Z_MAX_POS-25.0));
>       if (z_destination > destination[Z_AXIS]) {
>         destination[Z_AXIS] = z_destination;
>       }
>     #else
>       if (code_seen('Z')) destination[Z_AXIS] += code_value();
>       #ifdef FILAMENTCHANGE_ZADD
>         else destination[Z_AXIS] += FILAMENTCHANGE_ZADD;
>       #endif
6045a6956
>     SET_FEEDRATE_FOR_MOVE;
6058a6970
>     SET_FEEDRATE_FOR_MOVE;
6065a6978
>     SET_FEEDRATE_FOR_EXTRUDER_MOVE;
6068c6981
<     //finish moves
---
>     // validate planned all moves
6069a6983,7040
>
>     // DAGOMA added
>     // Determine exit/pin state after moving away
>     int pin_number = -1;
>     int target = -1;
>     if (code_seen('P')) {
>       char nextChar = *(seen_pointer + 1);
>       if (nextChar == 'A') {
>         pin_number = X_MIN_PIN;
>       }
>       else if (nextChar == 'B') {
>         pin_number = Y_MAX_PIN;
>       }
>       else if (nextChar == 'C') {
>         pin_number = Z_MIN_PIN;
>       }
>       else {
>         pin_number = code_value();
>       }
>
>       int pin_state = code_seen('S') ? code_value() : -1; // required pin state - default is inverted
>
>       if (pin_state >= -1 && pin_state <= 1) {
>
>         // DAGOMA - byPass sensitive pin
>         /*
>         for (uint8_t i = 0; i < COUNT(sensitive_pins); i++) {
>           if (sensitive_pins[i] == pin_number) {
>             pin_number = -1;
>             break;
>           }
>         }
>         */
>         if (pin_number > -1) {
>           target = LOW;
>
>           //pinMode(pin_number, INPUT);
>
>           switch (pin_state) {
>             case 1:
>               target = HIGH;
>               break;
>
>             case 0:
>               target = LOW;
>               break;
>
>             case -1:
>               target = !digitalRead(pin_number);
>               break;
>           }
>         } // pin_number > -1
>       } // pin_state -1 0 1
>     } // code_seen('P')
>     // END DAGOMA added
>
>
>
6075a7047
>     #if DISABLED(NO_LCD_FOR_FILAMENTCHANGEABLE)
6076a7049
>     #endif
6081,6088c7054,7062
<     while (!lcd_clicked()) {
<       #if DISABLED(AUTO_FILAMENT_CHANGE)
<         millis_t ms = millis();
<         if (ELAPSED(ms, next_tick)) {
<           lcd_quick_feedback();
<           next_tick = ms + 2500UL; // feedback every 2.5s while waiting
<         }
<         idle(true);
---
>
>     #if HAS_FILRUNOUT
>     bool can_exit_pause;
>     do { // Loop while no filament
>       can_exit_pause = true;
>     #endif
>
>       #if DISABLED(NO_LCD_FOR_FILAMENTCHANGEABLE)
>       while ( ! ( lcd_clicked() || (pin_number != -1 && digitalRead(pin_number) == target) ) ) {
6090,6093c7064,7131
<         current_position[E_AXIS] += AUTO_FILAMENT_CHANGE_LENGTH;
<         destination[E_AXIS] = current_position[E_AXIS];
<         line_to_destination(AUTO_FILAMENT_CHANGE_FEEDRATE);
<         st_synchronize();
---
>       while (pin_number != -1 && digitalRead(pin_number) != target) {
>       #endif
>         #if DISABLED(AUTO_FILAMENT_CHANGE)
>           millis_t ms = millis();
>           if (ELAPSED(ms, next_tick)) {
>             #if DISABLED(NO_LCD_FOR_FILAMENTCHANGEABLE)
>             lcd_quick_feedback();
>             #endif
>             next_tick = ms + 2500UL; // feedback every 2.5s while waiting
>
>             // Ensure steppers stay enabled
>             enable_x();
>             enable_y();
>             enable_z();
>
>
>             #if ENABLED( DELTA_EXTRA )
>               // Only checked every 2.5s
>               // Detected if sd is out
>               if ( IS_SD_PRINTING && !card.stillPluggedIn() ) {
>                 // Abort current print
>                 while( true ) {
>                   #if ENABLED(ONE_LED)
>                     one_led_on();
>                     delay(150);
>                     one_led_off();
>                   #endif
>                   delay(150);
>                 }
>                 //abort_sd_printing();
>                 //enqueue_and_echo_commands_P( PSTR("G28") );
>                 return;
>               }
>             #endif
>           }
>
>           #if ENABLED(DELTA_EXTRA) && ENABLED(Z_MIN_MAGIC)
>             // Must be check quicker than 2.5s
>             if ( z_magic_hit_count > 1 ) {
>               gcode_D600();
>             }
>           #endif
>
>           idle(true);
>         #else
>           current_position[E_AXIS] += AUTO_FILAMENT_CHANGE_LENGTH;
>           destination[E_AXIS] = current_position[E_AXIS];
>           line_to_destination(AUTO_FILAMENT_CHANGE_FEEDRATE);
>           st_synchronize();
>         #endif
>       } // while(!lcd_clicked)
>
>       #if ENABLED( NO_LCD_FOR_FILAMENTCHANGEABLE ) && ENABLED( FILAMENT_RUNOUT_SENSOR )
>         // Wait a bit more to see if we want to disable filrunout sensor
>         millis_t now = millis();
>         millis_t long_push = now + 2000UL;
>         delay( 200 );
>         while (pin_number != -1 && digitalRead(pin_number) == target && PENDING(now, long_push)) {
>           enable_x();
>           enable_y();
>           enable_z();
>           idle(true);
>           now = millis();
>         }
>         if ( ELAPSED(now,long_push) ) {
>           filrunout_bypassed = true;
>           SERIAL_ECHOLN( "Filament sensor bypassed" );
>         }
6095c7133,7149
<     } // while(!lcd_clicked)
---
>
>     #if HAS_FILRUNOUT
>         if( !(READ(FILRUNOUT_PIN) ^ FIL_RUNOUT_INVERTING) ) {
>           #if ENABLED(SUMMON_PRINT_PAUSE) && ENABLED( NO_LCD_FOR_FILAMENTCHANGEABLE ) && ENABLED( FILAMENT_RUNOUT_SENSOR )
>           if ( !filrunout_bypassed ) {
>           #endif
>             #if ENABLED(ONE_LED)
>               set_notify_warning();
>             #endif
>             can_exit_pause = false;
>           #if ENABLED(SUMMON_PRINT_PAUSE) && ENABLED( NO_LCD_FOR_FILAMENTCHANGEABLE ) && ENABLED( FILAMENT_RUNOUT_SENSOR )
>           }
>           #endif
>         }
>       } while( !can_exit_pause );
>     #endif
>
6096a7151
>     #if DISABLED(NO_LCD_FOR_FILAMENTCHANGEABLE)
6097a7153
>     #endif
6104c7160
<     //return to normal
---
>     // Return to normal
6112a7169
>     SET_FEEDRATE_FOR_EXTRUDER_MOVE;
6114a7172
>     #if DISABLED(NO_LCD_FOR_FILAMENTCHANGEABLE)
6115a7174
>     #endif
6120,6121c7179,7184
<       plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], destination[E_AXIS], fr60, active_extruder);
<       plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], lastpos[E_AXIS], fr60, active_extruder);
---
>
>       SET_FEEDRATE_FOR_MOVE;
>       plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], destination[E_AXIS], feedrate, active_extruder);
>
>       SET_FEEDRATE_FOR_EXTRUDER_MOVE;
>       plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], lastpos[E_AXIS], feedrate, active_extruder);
6125a7189,7190
>
>       SET_FEEDRATE_FOR_MOVE;
6128a7194
>
6129a7196,7197
>
>       SET_FEEDRATE_FOR_EXTRUDER_MOVE;
6132a7201,7203
>     // Validates all planned moves
>     st_synchronize();
>
6136a7208,7214
>     #if ENABLED(SUMMON_PRINT_PAUSE)
>       print_pause_summoned = false;
>     #endif
>
>     // Restore previous feedrate
>     feedrate = previous_feedrate;
>
6186a7265,7305
> /*****************************************************************************
>  * DAGOMA.FR Specific
>  *****************************************************************************/
> #if ENABLED(WIFI_PRINT)
> inline void gcode_D700() {
>   SECOND_SERIAL.print("SSID:");
>   SECOND_SERIAL.println(current_command_args);
> }
>
> inline void gcode_D701() {
>   SECOND_SERIAL.print("PSWD:");
>   SECOND_SERIAL.println(current_command_args);
> }
>
> inline void gcode_D702() {
>   SECOND_SERIAL.println("REDY");
> }
>
> inline void gcode_D710() {
>   SECOND_SERIAL.print("PNAM:");
>   SECOND_SERIAL.println(current_command_args);
> }
>
> inline void gcode_D711() {
>   SECOND_SERIAL.print("APIU:");
>   SECOND_SERIAL.println(current_command_args);
> }
>
> inline void gcode_D712() {
>   SECOND_SERIAL.print("APIK:");
>   SECOND_SERIAL.println(current_command_args);
> }
>
> inline void gcode_D720() {
>   SERIAL_ECHO_START;
>   SERIAL_ECHOPGM("D:");
>   SERIAL_ECHOLN(current_command_args);
> }
>
> #endif
>
6428a7548,7923
> #if ENABLED( DELTA_EXTRA )
>
> inline void abort_sd_printing() {
>   commands_in_queue = 0;
>   quickStop();
>   card.sdprinting = false;
>   card.closefile();
>   autotempShutdown();
>   setTargetHotend(0, 0);
>   cancel_heatup = true;
> }
>
> inline void gcode_D410() {
>   abort_sd_printing();
> }
>
> inline void gcode_D888() {
>   SERIAL_ECHOLN( "Bizarre procedure" );
>   float z_bizarre = 0.5;
>   if (code_seen('Z')) {
>     z_bizarre = code_value();
>   }
>   float f_bizarre = 3000;
>   if (code_seen('F')) {
>     f_bizarre = code_value();
>   }
>
>   float x_bizarre = 70;
>   if (code_seen('X')) {
>     x_bizarre = code_value();
>   }
>
>   int N = 100;
>   if (code_seen('N')) {
>     N = code_value();
>   }
>
>   for(int i=0; i<N; i++) {
>     feedrate = f_bizarre;
>     destination[X_AXIS] = x_bizarre;
>     destination[Y_AXIS] = 0;
>     destination[Z_AXIS] = z_bizarre;
>     prepare_move();
>     st_synchronize();
>
>     destination[X_AXIS] = x_bizarre + 10.0;
>
>     prepare_move();
>     st_synchronize();
>   }
> }
>
> inline void gcode_D999() {
>   SERIAL_ECHOLN( "Reseting board" );
>   while( true ) {
>     delay(1000);
>   }
> }
>
> inline void gcode_D851() {
>
>   startup_auto_calibration = true;
>
>   SERIAL_ECHOLNPGM( "Starting full Delta calibration" );
>
>   postcompute_tri_ready = false; // Disable tri-delta correction
>
>   gcode_M502(); // Restore factory settings
>
>   if (code_seen('L')) {
>     SERIAL_ECHOPGM( "Overriding L with: " );
>     delta_diagonal_rod = code_value();
>     SERIAL_ECHOLN( delta_diagonal_rod );
>   }
>
>   gcode_M665(); // Re-Calc Delta settings
>   gcode_M500(); // Save settings
>
>   gcode_G28();
>
>
>   feedrate = homing_feedrate[ Z_AXIS ];
>   //feedrate = max_feedrate[ Z_AXIS ] * 60;
>
>   float tower1_altitude, tower2_altitude, tower3_altitude, center_altitude;
>
>   // TOWER 1
>   destination[X_AXIS] = delta_tower1_x;
>   destination[Y_AXIS] = delta_tower1_y;
>   destination[Z_AXIS] = 10.0f;
>   prepare_move();
>   st_synchronize();
>   tower1_altitude = get_probed_Z_avg();
>
>   // TOWER 2
>   destination[X_AXIS] = delta_tower2_x;
>   destination[Y_AXIS] = delta_tower2_y;
>   destination[Z_AXIS] = 10.0f;
>   prepare_move();
>   st_synchronize();
>   tower2_altitude = get_probed_Z_avg();
>
>   // TOWER 3
>   destination[X_AXIS] = delta_tower3_x;
>   destination[Y_AXIS] = delta_tower3_y;
>   destination[Z_AXIS] = 10.0f;
>   prepare_move();
>   st_synchronize();
>   tower3_altitude = get_probed_Z_avg();
>
>   // Use last result as endstops adujst
>   endstop_adj[0] = tower1_altitude /*+ zprobe_zoffset*/;
>   endstop_adj[1] = tower2_altitude /*+ zprobe_zoffset*/;
>   endstop_adj[2] = tower3_altitude /*+ zprobe_zoffset*/;
>
>   // Store endstop adjust
>   gcode_M500();
>
>   // JUST FOR REPORTING BACK
>   // Take in account now
>   gcode_G28();
>
>   feedrate = homing_feedrate[ Z_AXIS ];
>
>   // TOWER 1
>   destination[X_AXIS] = delta_tower1_x;
>   destination[Y_AXIS] = delta_tower1_y;
>   destination[Z_AXIS] = 10.0f;
>   prepare_move();
>   st_synchronize();
>   tower1_altitude = get_probed_Z_avg();
>
>   // TOWER 2
>   destination[X_AXIS] = delta_tower2_x;
>   destination[Y_AXIS] = delta_tower2_y;
>   destination[Z_AXIS] = 10.0f;
>   prepare_move();
>   st_synchronize();
>   tower2_altitude = get_probed_Z_avg();
>
>   // TOWER 3
>   destination[X_AXIS] = delta_tower3_x;
>   destination[Y_AXIS] = delta_tower3_y;
>   destination[Z_AXIS] = 10.0f;
>   prepare_move();
>   st_synchronize();
>   tower3_altitude = get_probed_Z_avg();
>
>
>   // CENTER
>   destination[X_AXIS] = 0.0f;
>   destination[Y_AXIS] = 0.0f;
>   destination[Z_AXIS] = 10.0f;
>   prepare_move();
>   st_synchronize();
>   center_altitude = get_probed_Z_avg();
>
>   SERIAL_ECHOLNPGM( "R probed points:" );
>   SERIAL_ECHOPGM  ( "  T1: " );
>   SERIAL_ECHOLN   ( tower1_altitude );
>   SERIAL_ECHOPGM  ( "  T2: " );
>   SERIAL_ECHOLN   ( tower2_altitude );
>   SERIAL_ECHOPGM  ( "  T3: " );
>   SERIAL_ECHOLN   ( tower3_altitude );
>   SERIAL_ECHOPGM  ( "   C: " );
>   SERIAL_ECHOLN   ( center_altitude );
>
>   float mean_ref_plan_altitude = ( tower1_altitude + tower2_altitude + tower3_altitude ) / 3.0;
>   float diff_center_altitude = center_altitude - mean_ref_plan_altitude;
>
>   SERIAL_ECHOPGM( "Initial mean based difference: " );
>   SERIAL_ECHOLN ( diff_center_altitude );
>
>   SERIAL_ECHOPGM( "Initial delta radius: " );
>   SERIAL_ECHOLN ( delta_radius );
>
>   do {
>     delta_radius -= 2.0 * diff_center_altitude;
>
>     SERIAL_ECHOPGM( "Testing delta radius: " );
>     SERIAL_ECHOLN ( delta_radius );
>
>     gcode_M665();
>
>     destination[X_AXIS] = delta_tower1_x;
>     destination[Y_AXIS] = delta_tower1_y;
>     destination[Z_AXIS] = 10.0f;
>     prepare_move();
>     st_synchronize();
>     tower1_altitude = get_probed_Z_avg();
>
>     // TOWER 2
>     destination[X_AXIS] = delta_tower2_x;
>     destination[Y_AXIS] = delta_tower2_y;
>     destination[Z_AXIS] = 10.0f;
>     prepare_move();
>     st_synchronize();
>     tower2_altitude = get_probed_Z_avg();
>
>     // TOWER 3
>     destination[X_AXIS] = delta_tower3_x;
>     destination[Y_AXIS] = delta_tower3_y;
>     destination[Z_AXIS] = 10.0f;
>     prepare_move();
>     st_synchronize();
>     tower3_altitude = get_probed_Z_avg();
>
>     // CENTER
>     destination[X_AXIS] = 0.0f;
>     destination[Y_AXIS] = 0.0f;
>     destination[Z_AXIS] = 10.0f;
>     prepare_move();
>     st_synchronize();
>     center_altitude = get_probed_Z_avg();
>
>     SERIAL_ECHOLNPGM( "R probed points:" );
>     SERIAL_ECHOPGM  ( "  T1: " );
>     SERIAL_ECHOLN   ( tower1_altitude );
>     SERIAL_ECHOPGM  ( "  T2: " );
>     SERIAL_ECHOLN   ( tower2_altitude );
>     SERIAL_ECHOPGM  ( "  T3: " );
>     SERIAL_ECHOLN   ( tower3_altitude );
>     SERIAL_ECHOPGM  ( "   C: " );
>     SERIAL_ECHOLN   ( center_altitude );
>
>     mean_ref_plan_altitude = ( tower1_altitude + tower2_altitude + tower3_altitude ) / 3.0;
>     diff_center_altitude = center_altitude - mean_ref_plan_altitude;
>
>     SERIAL_ECHOPGM( "NEW Mean based difference: " );
>     SERIAL_ECHOLN ( diff_center_altitude );
>     SERIAL_ECHOPGM( "With delta radius: " );
>     SERIAL_ECHOLN ( delta_radius );
>   } while( abs( diff_center_altitude ) > 0.05 );
>
>
>   SERIAL_ECHOPGM( "Storing delta radius: " );
>   SERIAL_ECHOLN ( delta_radius );
>
>   // Store delta_radius
>   gcode_M500();
>
>   // Take in account now
>   gcode_G28();
>   // Now, we need to adjust endstops offset with the corrected radius
>
>   // TOWER 1
>   destination[X_AXIS] = delta_tower1_x;
>   destination[Y_AXIS] = delta_tower1_y;
>   destination[Z_AXIS] = 10.0f;
>   prepare_move();
>   st_synchronize();
>   tower1_altitude = get_probed_Z_avg();
>
>   // TOWER 2
>   destination[X_AXIS] = delta_tower2_x;
>   destination[Y_AXIS] = delta_tower2_y;
>   destination[Z_AXIS] = 10.0f;
>   prepare_move();
>   st_synchronize();
>   tower2_altitude = get_probed_Z_avg();
>
>   // TOWER 3
>   destination[X_AXIS] = delta_tower3_x;
>   destination[Y_AXIS] = delta_tower3_y;
>   destination[Z_AXIS] = 10.0f;
>   prepare_move();
>   st_synchronize();
>   tower3_altitude = get_probed_Z_avg();
>
>   // CENTER
>   destination[X_AXIS] = 0.0f;
>   destination[Y_AXIS] = 0.0f;
>   destination[Z_AXIS] = 10.0f;
>   prepare_move();
>   st_synchronize();
>   center_altitude = get_probed_Z_avg();
>
>   SERIAL_ECHOLNPGM( "R probed points:" );
>   SERIAL_ECHOPGM  ( "  T1: " );
>   SERIAL_ECHOLN   ( tower1_altitude );
>   SERIAL_ECHOPGM  ( "  T2: " );
>   SERIAL_ECHOLN   ( tower2_altitude );
>   SERIAL_ECHOPGM  ( "  T3: " );
>   SERIAL_ECHOLN   ( tower3_altitude );
>   SERIAL_ECHOPGM  ( "   C: " );
>   SERIAL_ECHOLN   ( center_altitude );
>
>   mean_ref_plan_altitude = ( tower1_altitude + tower2_altitude + tower3_altitude ) / 3.0;
>   diff_center_altitude = center_altitude - mean_ref_plan_altitude;
>
>   SERIAL_ECHOPGM( "Mean based difference: " );
>   SERIAL_ECHOLN( diff_center_altitude );
>
>   SERIAL_ECHOPGM( "With delta radius: " );
>   SERIAL_ECHOLN ( delta_radius );
>
>   // Use last result as endstops adujst
>   endstop_adj[0] += tower1_altitude /*+ zprobe_zoffset*/;
>   endstop_adj[1] += tower2_altitude /*+ zprobe_zoffset*/;
>   endstop_adj[2] += tower3_altitude /*+ zprobe_zoffset*/;
>
>   // Store endstop adjust
>   gcode_M500();
>
>   #if ENABLED(DEBUG_LEVELING_FEATURE)
>     if (DEBUGGING(LEVELING)) {
>
>       // JUST FOR REPORTING BACK
>       // Take in account now
>       gcode_G28();
>
>       // TOWER 1
>       destination[X_AXIS] = delta_tower1_x;
>       destination[Y_AXIS] = delta_tower1_y;
>       destination[Z_AXIS] = 10.0f;
>       prepare_move();
>       st_synchronize();
>       tower1_altitude = get_probed_Z_avg();
>
>       // TOWER 2
>       destination[X_AXIS] = delta_tower2_x;
>       destination[Y_AXIS] = delta_tower2_y;
>       destination[Z_AXIS] = 10.0f;
>       prepare_move();
>       st_synchronize();
>       tower2_altitude = get_probed_Z_avg();
>
>       // TOWER 3
>       destination[X_AXIS] = delta_tower3_x;
>       destination[Y_AXIS] = delta_tower3_y;
>       destination[Z_AXIS] = 10.0f;
>       prepare_move();
>       st_synchronize();
>       tower3_altitude = get_probed_Z_avg();
>
>       // CENTER
>       destination[X_AXIS] = 0.0f;
>       destination[Y_AXIS] = 0.0f;
>       destination[Z_AXIS] = 10.0f;
>       prepare_move();
>       st_synchronize();
>       center_altitude = get_probed_Z_avg();
>
>        SERIAL_ECHOLNPGM( "R probed points:" );
>       SERIAL_ECHOPGM  ( "  T1: " );
>       SERIAL_ECHOLN   ( tower1_altitude );
>       SERIAL_ECHOPGM  ( "  T2: " );
>       SERIAL_ECHOLN   ( tower2_altitude );
>       SERIAL_ECHOPGM  ( "  T3: " );
>       SERIAL_ECHOLN   ( tower3_altitude );
>       SERIAL_ECHOPGM  ( "   C: " );
>       SERIAL_ECHOLN   ( center_altitude );
>
>       mean_ref_plan_altitude = ( tower1_altitude + tower2_altitude + tower3_altitude ) / 3.0;
>       diff_center_altitude = center_altitude - mean_ref_plan_altitude;
>
>       SERIAL_ECHOPGM( "Mean based difference: " );
>       SERIAL_ECHOLN( diff_center_altitude );
>
>       SERIAL_ECHOPGM( "With delta radius: " );
>       SERIAL_ECHOLN ( delta_radius );
>     }
>   #endif
>
>   gcode_G28();
>
>   startup_auto_calibration = false;
> }
>
> #if ENABLED(Z_MIN_MAGIC)
> // Pre-declaration
> inline void gcode_D600();
> #endif
>
> #endif // DELTA_EXTRA End
>
7046a8542,8588
>     case 'D': switch (codenum) {
>       // DAGOMA.FR Specific
>       #if ENABLED(WIFI_PRINT)
>         case 700:
>           gcode_D700(); // SSID
>           break;
>         case 701:
>           gcode_D701(); // PSWD
>           break;
>         case 702:
>           gcode_D702(); // REDY? get ip
>           break;
>         case 710:
>           gcode_D710(); // Tech name
>           break;
>         case 711:
>           gcode_D711(); // API Url
>           break;
>         case 712:
>           gcode_D712(); // API Key
>           break;
>         case 720:
>           gcode_D720(); // ECHO
>           break;
>         #endif
>       #if ENABLED( DELTA_EXTRA )
>         case 410:
>           gcode_D410();
>           break;
>         #if ENABLED(Z_MIN_MAGIC)
>           case 600:
>             gcode_D600();
>             break;
>         #endif
>         case 851:
>           gcode_D851();
>           break;
>         case 888:
>           gcode_D888();
>           break;
>         case 999:
>           gcode_D999();
>           break;
>       #endif
>       // DAGOMA.FR End
>       }
>     break;
7125a8668,8750
>
>     #if ENABLED( DELTA_EXTRA )
>       int i=0;
>       // Outer
>       probe_plan[i][0] = delta_tower1_x;
>       probe_plan[i][1] = delta_tower1_y;
>       i++;
>
>       probe_plan[i][0] = -COS_60 * radius;
>       probe_plan[i][1] = -SIN_60 * radius;
>       i++;
>
>       probe_plan[i][0] = 0.0;
>       probe_plan[i][1] = -1.0 * radius;
>       i++;
>
>       probe_plan[i][0] = COS_60 * radius;
>       probe_plan[i][1] = -SIN_60 * radius;
>       i++;
>
>       probe_plan[i][0] = delta_tower2_x;
>       probe_plan[i][1] = delta_tower2_y;
>       i++;
>
>       probe_plan[i][0] = radius;
>       probe_plan[i][1] = 0.0;
>       i++;
>
>       probe_plan[i][0] = SIN_60 * radius;
>       probe_plan[i][1] = COS_60 * radius;
>       i++;
>
>       probe_plan[i][0] = COS_60 * radius;
>       probe_plan[i][1] = SIN_60 * radius;
>       i++;
>
>       probe_plan[i][0] = delta_tower3_x;
>       probe_plan[i][1] = delta_tower3_y;
>       i++;
>
>       probe_plan[i][0] = -COS_60 * radius;
>       probe_plan[i][1] = SIN_60 * radius;
>       i++;
>
>       probe_plan[i][0] = -SIN_60 * radius;
>       probe_plan[i][1] = COS_60 * radius;
>       i++;
>
>       probe_plan[i][0] = -radius;
>       probe_plan[i][1] = 0.0;
>       i++;
>
>       // Inner
>       probe_plan[i][0] = -SIN_60 * radius / 2.0;
>       probe_plan[i][1] = -COS_60 * radius / 2.0;
>       i++;
>
>       probe_plan[i][0] = 0.0;
>       probe_plan[i][1] = -radius / 2.0;
>       i++;
>
>       probe_plan[i][0] = SIN_60 * radius / 2.0;
>       probe_plan[i][1] = -COS_60 * radius / 2.0;
>       i++;
>
>       probe_plan[i][0] = SIN_60 * radius / 2.0;
>       probe_plan[i][1] = COS_60 * radius / 2.0;
>       i++;
>
>       probe_plan[i][0] = 0.0;
>       probe_plan[i][1] = radius / 2.0;
>       i++;
>
>       probe_plan[i][0] = -SIN_60 * radius / 2.0;
>       probe_plan[i][1] = COS_60 * radius / 2.0;
>       i++;
>
>       // Center
>       probe_plan[i][0] = 0.0;
>       probe_plan[i][1] = 0.0;
>       i++;
>
>     #endif
7154a8780,8788
>     inline float triangle_get_point_offset( const float x, const float y, const short t ) {
>       // z = - (d + b.y + a.x) / c ;
>       return - (
>         probed_tri_postcompute_d[t] +
>         probed_tri_postcompute_b[t] * y +
>         probed_tri_postcompute_a[t] * x
>       ) / probed_tri_postcompute_c[t];
>     }
>
7157c8791,8792
<       if (delta_grid_spacing[0] == 0 || delta_grid_spacing[1] == 0) return; // G29 not done!
---
>       #if DISABLED( DELTA_EXTRA )
>         if (delta_grid_spacing[0] == 0 || delta_grid_spacing[1] == 0) return; // G29 not done!
7159,7175c8794,8810
<       int half = (AUTO_BED_LEVELING_GRID_POINTS - 1) / 2;
<       float h1 = 0.001 - half, h2 = half - 0.001,
<             grid_x = max(h1, min(h2, cartesian[X_AXIS] / delta_grid_spacing[0])),
<             grid_y = max(h1, min(h2, cartesian[Y_AXIS] / delta_grid_spacing[1]));
<       int floor_x = floor(grid_x), floor_y = floor(grid_y);
<       float ratio_x = grid_x - floor_x, ratio_y = grid_y - floor_y,
<             z1 = bed_level[floor_x + half][floor_y + half],
<             z2 = bed_level[floor_x + half][floor_y + half + 1],
<             z3 = bed_level[floor_x + half + 1][floor_y + half],
<             z4 = bed_level[floor_x + half + 1][floor_y + half + 1],
<             left = (1 - ratio_y) * z1 + ratio_y * z2,
<             right = (1 - ratio_y) * z3 + ratio_y * z4,
<             offset = (1 - ratio_x) * left + ratio_x * right;
<
<       delta[X_AXIS] += offset;
<       delta[Y_AXIS] += offset;
<       delta[Z_AXIS] += offset;
---
>         int half = (AUTO_BED_LEVELING_GRID_POINTS - 1) / 2;
>         float h1 = 0.001 - half, h2 = half - 0.001,
>               grid_x = max(h1, min(h2, cartesian[X_AXIS] / delta_grid_spacing[0])),
>               grid_y = max(h1, min(h2, cartesian[Y_AXIS] / delta_grid_spacing[1]));
>         int floor_x = floor(grid_x), floor_y = floor(grid_y);
>         float ratio_x = grid_x - floor_x, ratio_y = grid_y - floor_y,
>               z1 = bed_level[floor_x + half][floor_y + half],
>               z2 = bed_level[floor_x + half][floor_y + half + 1],
>               z3 = bed_level[floor_x + half + 1][floor_y + half],
>               z4 = bed_level[floor_x + half + 1][floor_y + half + 1],
>               left = (1 - ratio_y) * z1 + ratio_y * z2,
>               right = (1 - ratio_y) * z3 + ratio_y * z4,
>               offset = (1 - ratio_x) * left + ratio_x * right;
>
>         delta[X_AXIS] += offset;
>         delta[Y_AXIS] += offset;
>         delta[Z_AXIS] += offset;
7177,7191c8812,8855
<       /**
<       SERIAL_ECHOPGM("grid_x="); SERIAL_ECHO(grid_x);
<       SERIAL_ECHOPGM(" grid_y="); SERIAL_ECHO(grid_y);
<       SERIAL_ECHOPGM(" floor_x="); SERIAL_ECHO(floor_x);
<       SERIAL_ECHOPGM(" floor_y="); SERIAL_ECHO(floor_y);
<       SERIAL_ECHOPGM(" ratio_x="); SERIAL_ECHO(ratio_x);
<       SERIAL_ECHOPGM(" ratio_y="); SERIAL_ECHO(ratio_y);
<       SERIAL_ECHOPGM(" z1="); SERIAL_ECHO(z1);
<       SERIAL_ECHOPGM(" z2="); SERIAL_ECHO(z2);
<       SERIAL_ECHOPGM(" z3="); SERIAL_ECHO(z3);
<       SERIAL_ECHOPGM(" z4="); SERIAL_ECHO(z4);
<       SERIAL_ECHOPGM(" left="); SERIAL_ECHO(left);
<       SERIAL_ECHOPGM(" right="); SERIAL_ECHO(right);
<       SERIAL_ECHOPGM(" offset="); SERIAL_ECHOLN(offset);
<       */
---
>         /**
>         SERIAL_ECHOPGM("grid_x="); SERIAL_ECHO(grid_x);
>         SERIAL_ECHOPGM(" grid_y="); SERIAL_ECHO(grid_y);
>         SERIAL_ECHOPGM(" floor_x="); SERIAL_ECHO(floor_x);
>         SERIAL_ECHOPGM(" floor_y="); SERIAL_ECHO(floor_y);
>         SERIAL_ECHOPGM(" ratio_x="); SERIAL_ECHO(ratio_x);
>         SERIAL_ECHOPGM(" ratio_y="); SERIAL_ECHO(ratio_y);
>         SERIAL_ECHOPGM(" z1="); SERIAL_ECHO(z1);
>         SERIAL_ECHOPGM(" z2="); SERIAL_ECHO(z2);
>         SERIAL_ECHOPGM(" z3="); SERIAL_ECHO(z3);
>         SERIAL_ECHOPGM(" z4="); SERIAL_ECHO(z4);
>         SERIAL_ECHOPGM(" left="); SERIAL_ECHO(left);
>         SERIAL_ECHOPGM(" right="); SERIAL_ECHO(right);
>         SERIAL_ECHOPGM(" offset="); SERIAL_ECHOLN(offset);
>         */
>       #else // if DELTA_EXTRA
>         if ( ! postcompute_tri_ready ) return;
>
>         if ( cartesian[Z_AXIS] > z_smooth_tri_leveling_height ) return;
>
>         // Find the index tri for z correction
>         short idx = triangle_index( cartesian[X_AXIS], cartesian[Y_AXIS] );
>
>         // Get offset from tri equations
>         float offset = triangle_get_point_offset( cartesian[X_AXIS], cartesian[Y_AXIS], idx );
>
>         // Adjust final-offset againt Z altitude
>         // to reduce it after 0.6mm
>         offset *= ( z_smooth_tri_leveling_height - cartesian[Z_AXIS] ) / z_smooth_tri_leveling_height;
>
>         delta[X_AXIS] += offset;
>         delta[Y_AXIS] += offset;
>         delta[Z_AXIS] += offset;
>
>         delta[X_AXIS] += zprobe_zoffset;
>         delta[Y_AXIS] += zprobe_zoffset;
>         delta[Z_AXIS] += zprobe_zoffset;
>
>         // Bed support smoothness
>         delta[X_AXIS] += 0.05;
>         delta[Y_AXIS] += 0.05;
>         delta[Z_AXIS] += 0.05;
>
>       #endif // End DELTA_EXTRA
7735a9400,9568
> #if ENABLED(ONE_BUTTON)
>
>   millis_t next_one_button_check = 0;
>   bool asked_to_print = false;
>   bool asked_to_pause = false;
>   millis_t has_to_print_timeout = 0;
>
> #endif
>
> #if ENABLED(ONE_LED)
>
>   int state_blink = 0;
>   millis_t next_one_led_tick = 0;
>   bool notify_warning = false;
>   millis_t notify_warning_timeout = 0;
>
>   inline void set_notify_warning() {
>     notify_warning = true;
>     notify_warning_timeout = millis() + 2000UL;
>   }
>
>   inline void manage_one_led() {
>     millis_t now = millis();
>     if ( PENDING( now, next_one_led_tick ) ) return;
>
>     state_blink = ( state_blink + 1 ) % 10;
>     next_one_led_tick = now + 150UL;
>
>     if ( startup_auto_calibration ) {
>       switch( state_blink ) {
>         case 0:
>           one_led_on();
>           break;
>         default:
>           one_led_off();
>       }
>     }
>     #if ENABLED( ONE_BUTTON )
>     else if ( asked_to_print ) {
>       one_led_on();
>     }
>     #endif
>     else if ( notify_warning ) {
>       state_blink % 2 ? one_led_on() : one_led_off();
>       if ( ELAPSED(now, notify_warning_timeout) ) {
>         notify_warning = false;
>       }
>     }
>     else if (
>       false
>       #if ENABLED(SUMMON_PRINT_PAUSE)
>       || print_pause_summoned
>       #endif
>       #if ENABLED(FILAMENT_RUNOUT_SENSOR)
>       || filament_ran_out
>       #endif
>     ) {
>       switch( state_blink ) {
>         case 0:
>         case 2:
>           one_led_on();
>           break;
>         default:
>           one_led_off();
>       }
>     }
>     else {
>       if ( IS_SD_PRINTING ) {
>         one_led_on();
>       }
>       else {
>         one_led_off();
>       }
>     }
>   }
> #endif
>
> #if ENABLED(SUMMON_PRINT_PAUSE)
>
>   inline void manage_pause_summoner() {
>     // PAUSE PUSHED
>     if (!print_pause_summoned
>       #if ENABLED( FILAMENT_RUNOUT_SENSOR )
>       && !filament_ran_out
>       #endif
>       #if ENABLED( ONE_BUTTON )
>       && !asked_to_print
>       #endif
>       ) {
>       if (
>         IS_SD_PRINTING
>         && ( READ(SUMMON_PRINT_PAUSE_PIN) ^ SUMMON_PRINT_PAUSE_INVERTING )
>         && axis_homed[X_AXIS]
>         && axis_homed[Y_AXIS]
>         && axis_homed[Z_AXIS]
>         ) {
>           SERIAL_ECHOLNPGM("Pause : Summoned by user bouton press");
>           print_pause_summoned = true;
>           enqueue_and_echo_commands_P(PSTR(SUMMON_PRINT_PAUSE_SCRIPT));
>       }
>     }
>   }
>
> #endif // SUMMON_PRINT_PAUSE
>
> #if ENABLED(ONE_BUTTON)
>
>   inline void manage_one_button() {
>     // De-Bounce bouton press
>     millis_t now = millis();
>     if (PENDING(now, next_one_button_check)) return;
>     next_one_button_check = now + 100UL;
>
>     if ( IS_SD_PRINTING
>       && asked_to_print
>       && !( READ(ONE_BUTTON_PIN) ^ ONE_BUTTON_INVERTING )
>     ) {
>       asked_to_print = false;
>     }
>
>     if ( !IS_SD_PRINTING
>       && asked_to_print
>       && !( READ(ONE_BUTTON_PIN) ^ ONE_BUTTON_INVERTING )
>       && ELAPSED(now, has_to_print_timeout)
>     ) {
>       asked_to_print = false;
>       #if ENABLED(ONE_LED)
>         set_notify_warning();
>       #endif
>     }
>
>     if ( !startup_auto_calibration
>       && !IS_SD_PRINTING
>       && !asked_to_print
>       && ( READ(ONE_BUTTON_PIN) ^ ONE_BUTTON_INVERTING )
>     ) {
>       // Warns user if no filament at start/resume.
>       #if HAS_FILRUNOUT
>         if( !(READ(FILRUNOUT_PIN) ^ FIL_RUNOUT_INVERTING) ) {
>           set_notify_warning();
>           return;
>         }
>       #endif
>
>       #if ENABLED( FILAMENT_RUNOUT_SENSOR )
>         filrunout_bypassed = false;
>       #endif
>       asked_to_print = true;
>       has_to_print_timeout = now + 2500UL;
>
>       #if ENABLED(ONE_LED)
>         one_led_on();
>       #endif
>
>       card.autostart_index = 0;
>       card.cardOK = false;
>       card.checkautostart( true );
>
>       #if ENABLED(ONE_LED)
>         if ( !card.cardOK ) set_notify_warning();
>       #endif
>     }
>   }
> #endif
>
> #if ENABLED( Z_MIN_MAGIC )
>   millis_t last_debug_z_magic_timing = 0UL;
> #endif
>
7743a9577,9584
>
> /*
>   if (z_magic_derivative_bias < -5.0) {
>     SERIAL_ECHO("z_magic_d: ");
>     SERIAL_ECHOLN(z_magic_derivative_bias);
>   }
> */
>
7744a9586,9597
>   #if ENABLED(SUMMON_PRINT_PAUSE)
>   manage_pause_summoner();
>   #endif
>   #if ENABLED(ONE_BUTTON)
>   manage_one_button();
>   #endif
>   #if ENABLED(ONE_LED)
>   manage_one_led();
>   #endif
>   #if ENABLED(DELTA_EXTRA) && ENABLED(Z_MIN_MAGIC)
>   manage_tap_tap();
>   #endif
7751c9604,9645
<   lcd_update();
---
>   #if ENABLED(U8GLIB_SSD1306) && ENABLED(INTELLIGENT_LCD_REFRESH_RATE)
>     if (IS_SD_PRINTING && axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS]) {
>
>       if ( last_intelligent_F_lcd_update != feedrate ) {
>         last_intelligent_F_authorized_lcd_update = feedrate > last_intelligent_F_lcd_update;
>         last_intelligent_F_lcd_update = feedrate;
>       }
>
>       if ( last_intelligent_z_lcd_update != current_position[Z_AXIS] || last_intelligent_F_authorized_lcd_update ) {
>         last_intelligent_z_lcd_update = current_position[Z_AXIS];
>         lcd_update();
>       }
>
>     }
>     else {
>       lcd_update();
>     }
>   #else
>     lcd_update();
>   #endif
>
>   #if ENABLED( WIFI_PRINT )
>     manage_second_serial_status();
>   #endif
>
>   #if ENABLED( Z_MIN_MAGIC )
>     if (DEBUGGING(LEVELING)) {
>       millis_t now = millis();
>       if (ELAPSED(now, last_debug_z_magic_timing)) {
>         SERIAL_ECHOPGM("Z Magic (tstp / pressure / bias / tap): ");
>         SERIAL_ECHO( millis() );
>         SERIAL_ECHOPGM(" / ");
>         SERIAL_ECHO( z_magic_value );
>         SERIAL_ECHOPGM(" / ");
>         SERIAL_ECHO( z_magic_derivative_bias );
>         SERIAL_ECHOPGM(" / ");
>         SERIAL_ECHO( z_magic_hit_count );
>         SERIAL_ECHOLNPGM("");
>         last_debug_z_magic_timing = now + 250UL; // 2times a second
>       }
>     }
>   #endif
7766a9661
>   millis_t ms = millis();
7769,7770c9664,9684
<     if (IS_SD_PRINTING && !(READ(FILRUNOUT_PIN) ^ FIL_RUNOUT_INVERTING))
<       handle_filament_runout();
---
>     if (
>       IS_SD_PRINTING
>       #if ENABLED( SUMMON_PRINT_PAUSE )
>       && !filrunout_bypassed
>       && !print_pause_summoned
>       #endif
>       && !(READ(FILRUNOUT_PIN) ^ FIL_RUNOUT_INVERTING)
>       && axis_homed[X_AXIS]
>       && axis_homed[Y_AXIS]
>       && axis_homed[Z_AXIS]
>       ) {
>       if(ELAPSED(ms, frs_debounce_time)) {
>         if (frs_debounce_time == 0UL) {
>           frs_debounce_time = ms + FRS_DEBOUNCE_DELAY;
>         } else {
>           handle_filament_runout();
>         }
>       }
>     } else {
>       frs_debounce_time = 0UL;
>     }
7775,7776d9688
<   millis_t ms = millis();
<
7839a9752,9783
>   #if ENABLED(IS_MONO_FAN) || ENABLED(PRINTER_HEAD_EASY)
>     if ( ELAPSED(ms, next_fan_auto_regulation_check) ) {
>       float max_temp = 0.0;
>       for (int8_t cur_extruder = 0; cur_extruder < EXTRUDERS; ++cur_extruder)
>         max_temp = max(max_temp, degHotend(cur_extruder));
>
>       #if ENABLED(IS_MONO_FAN)
>         short fs = 0;
>         if ( max_temp < MONO_FAN_MIN_TEMP ) {
>           fs = 0;
>         }
>         else {
>           fs = fanSpeeds[0];
>           NOLESS(fs, MONO_FAN_MIN_PWM);
>         }
>
>         fanSpeeds[0] = fs;
>       #endif
>
>       #if ENABLED(PRINTER_HEAD_EASY)
>         if ( max_temp < PRINTER_HEAD_EASY_CONSTANT_FAN_MIN_TEMP ) {
>           analogWrite(PRINTER_HEAD_EASY_CONSTANT_FAN_PIN, 0);
>         }
>         else {
>           analogWrite(PRINTER_HEAD_EASY_CONSTANT_FAN_PIN, 255);
>         }
>       #endif
>
>       next_fan_auto_regulation_check = ms + 2500UL;
>     }
>   #endif
>
7927a9872,9904
>   #if ENABLED( DELTA_EXTRA )
>     #if ENABLED( SDSUPPORT )
>       // Dump error msg onto sd card
>       abort_sd_printing();
>       card.initsd();
>       if ( card.cardOK ) {
>         char logfilename[30];
>         sprintf_P(logfilename, PSTR("errmsg.d"));
>         // First, delete previous if exists
>         card.removeFile( logfilename );
>         // Then, create it
>         card.openLogFile( logfilename );
>         if ( card.saving ) {
>           if ( card.writePGM( lcd_msg ) ) {
>             SERIAL_ECHOLNPGM( "errmsg.d : file written, for more information." );
>           }
>           else {
>             SERIAL_ECHOLNPGM( "errmsg.d : can't write file content" );
>           }
>           card.closefile();
>           card.release();
>         }
>         else {
>           SERIAL_ECHOLNPGM( "errmsg.d : can't create file" );
>         }
>       }
>       else {
>         SERIAL_ECHOLNPGM( "errmsg.d : can't init sd card" );
>       }
>     #endif
>     gcode_G28();
>   #endif
>
7942c9919,9921
<   cli();   // disable interrupts
---
>   #if DISABLED( ONE_LED )
>     cli();   // disable interrupts
>   #endif
7947a9927,9932
>     #if ENABLED( ONE_LED )
>       one_led_on();
>       delay(70);
>       one_led_off();
>       delay(140);
>     #endif
7952d9936
<
7954a9939
>       SERIAL_ECHOLNPGM("Pause : No more filament detected");
diff Marlin/pins.h ../DiscoEasy200/pins.h
279a280,295
> #undef HEATER_1_PIN
> #define HEATER_1_PIN -1
> #undef PRINTER_HEAD_EASY_CONSTANT_FAN_PIN
> #define PRINTER_HEAD_EASY_CONSTANT_FAN_PIN 7
> #undef X_MAX_PIN
> #define X_MAX_PIN -1
> #undef X_MIN_PIN
> #define X_MIN_PIN 2
> #undef Y_MAX_PIN
> #define Y_MAX_PIN 3
> #undef Y_MIN_MIN
> #define Y_MIN_MIN -1
> #undef Z_MAX_PIN
> #define Z_MAX_PIN -1
> #undef Z_MIN_PIN
> #define Z_MIN_PIN 15
Seulement dans ../DiscoEasy200/: .pioenvs
Seulement dans ../DiscoEasy200/: .piolibdeps
Seulement dans ../DiscoEasy200/: platformio.ini
Les sous-répertoires Marlin/scripts et ../DiscoEasy200/scripts sont identiques
diff Marlin/stepper.cpp ../DiscoEasy200/stepper.cpp
115a116,119
> #if ENABLED(EMERGENCY_STOP)
>   bool trigger_emergency_stop = false;
> #endif
>
339a344,350
> #if ENABLED( Z_MIN_MAGIC )
>   #define LAST_MEASURE_NUMBER 10
>   volatile float last_measures[LAST_MEASURE_NUMBER] = { 0.0 };
>   volatile float last_measures_avg = { 0.0 };
>   volatile int last_measures_idx = 0;
> #endif
>
473d483
<
482,484c492,513
<         #if ENABLED(Z_MIN_PROBE_ENDSTOP) && DISABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) && ENABLED(HAS_Z_MIN_PROBE)
<           if (z_probe_is_active) {
<             UPDATE_ENDSTOP(Z, MIN_PROBE);
---
>         // Check if pause is triggered during z probe
>         #if ENABLED(HAS_Z_MIN_PROBE)
>           #if ENABLED(EMERGENCY_STOP)
>             #if ENABLED(DELTA) && ENABLED(ONE_BUTTON) // Delta
>               if ( (READ(ONE_BUTTON_PIN) ^ ONE_BUTTON_INVERTING) ) {
>                 SET_BIT(current_endstop_bits, Z_MIN_PROBE, 1 ); // Emulate endstops hit (here: Z_MIN)
>                 trigger_emergency_stop = true;
>               }
>             #elif ENABLED(SUMMON_PRINT_PAUSE) // E200 Neva-like (with pause button)
>               if ( (READ(SUMMON_PRINT_PAUSE_PIN) ^ SUMMON_PRINT_PAUSE_INVERTING) ) {
>                 SET_BIT(current_endstop_bits, Z_MIN_PROBE, 1 ); // Emulate endstops hit (here: Z_MIN)
>                 trigger_emergency_stop = true;
>               }
>             #endif
>
>             // Assumption: this piece of code is used to stop the move in checking bit in Z_MIN_PROBE flag.
>             if (TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE)) && current_block->steps[_AXIS(Z)] > 0) {
>               _SET_TRIGSTEPS(Z);
>               _ENDSTOP_HIT(Z);
>               step_events_completed = current_block->step_event_count;
>             }
>
486c515,569
<           }
---
>
>             // FIXME: Quick fix to exit earlier
>             //        If emergency stop is triggered
>             // TODO:  See if this code can be avoided with below Z_MIN_MAGIC possible override
>             //        of emergency occurrences
>             if (trigger_emergency_stop) {
>               old_endstop_bits = current_endstop_bits;
>               return;
>             }
>           #endif
>         #endif
>
>         #if ENABLED(Z_MIN_PROBE_ENDSTOP) && DISABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) && ENABLED(HAS_Z_MIN_PROBE)
>           #if ENABLED( Z_MIN_MAGIC )
>               if ( z_probe_is_active /*&& can_measure_z_magic*/ ) {
>                 //int z_sensor_i = analogRead( Z_MIN_PROBE_PIN );
>                 int z_sensor_i = z_magic_value;
>                 float z_sensor_f = float( z_sensor_i );
>                 float derivative_bias = ( z_sensor_f - last_measures_avg ) / 2.0;
>
>                 /*if ( derivative_bias > -2.0 ) {*/
>                 if ( z_magic_derivative_bias > -5.0 ) {
>                   // We do not hit anything
>                   SET_BIT(current_endstop_bits, Z_MIN_PROBE, 0 );
>                 }
>                 else {
>                   // We hit something
>                   SET_BIT(current_endstop_bits, Z_MIN_PROBE, 1 );
>                 }
>
>                 // Update last_measures avg
>                 last_measures[ last_measures_idx ] = z_sensor_f;
>                 last_measures_idx = ( last_measures_idx + 1 ) % LAST_MEASURE_NUMBER;
>
>                 last_measures_avg = last_measures[0];
>                 for( int i=1; i<LAST_MEASURE_NUMBER; i++ ) {
>                   last_measures_avg += last_measures[ i ];
>                 }
>                 last_measures_avg /= float( LAST_MEASURE_NUMBER );
>
>                 if (TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE)) && current_block->steps[_AXIS(Z)] > 0) {
>                   _SET_TRIGSTEPS(Z);
>                   _ENDSTOP_HIT(Z);
>                   step_events_completed = current_block->step_event_count;
>                 }
>
>                 if (TEST_ENDSTOP(Z_MIN_PROBE)) SBI(endstop_hit_bits, Z_MIN_PROBE);
>
>               } // END z_probe_is_active
>           #else
>             if (z_probe_is_active) {
>               UPDATE_ENDSTOP(Z, MIN_PROBE);
>               if (TEST_ENDSTOP(Z_MIN_PROBE)) SBI(endstop_hit_bits, Z_MIN_PROBE);
>             }
>           #endif
diff Marlin/stepper.h ../DiscoEasy200/stepper.h
52a53,56
> #if ENABLED(EMERGENCY_STOP)
>   extern bool trigger_emergency_stop;
> #endif
>
diff Marlin/temperature.cpp ../DiscoEasy200/temperature.cpp
239c239
<     #if HAS_AUTO_FAN
---
>     #if HAS_AUTO_FAN || ENABLED(IS_MONO_FAN) || ENABLED(PRINTER_HEAD_EASY)
293c293
<         #if HAS_AUTO_FAN
---
>         #if HAS_AUTO_FAN || ENABLED(IS_MONO_FAN) || ENABLED(PRINTER_HEAD_EASY)
294a295
>             #if HAS_AUTO_FAN
295a297,305
>             #endif
>             #if ENABLED(IS_MONO_FAN)
>             digitalWrite(FAN_PIN, MONO_FAN_MIN_PWM);
>             analogWrite(FAN_PIN, MONO_FAN_MIN_PWM);
>             #endif
>             #if ENABLED(PRINTER_HEAD_EASY)
>             digitalWrite(PRINTER_HEAD_EASY_CONSTANT_FAN_PIN, 255);
>             analogWrite(PRINTER_HEAD_EASY_CONSTANT_FAN_PIN, 255);
>             #endif
1379a1390,1458
> #if ENABLED( Z_MIN_MAGIC )
>   bool can_measure_z_magic = false;
>   static unsigned long raw_z_magic_value = 0;
>
>   #define Z_MAGIC_LAST_MEASURES_NUMBER 5
>   volatile float z_magic_last_measures[Z_MAGIC_LAST_MEASURES_NUMBER] = { 0.0 };
>   volatile float z_magic_last_measures_avg = 0.0 ;
>   volatile int z_magic_last_measures_idx = 0;
>   float z_magic_derivative_bias = 0.0;
>
>   #define Z_MAGIC_DERIVATIVE_BIAS_THRESHOLD (8.0)
>   #define Z_MAGIC_MIN_ELASTICITY_RESPONSE_MILLIS 50UL
>   #define Z_MAGIC_MAX_ELASTICITY_RESPONSE_MILLIS 80UL
>   #define Z_MAGIC_EDGE_DELAY_MILLIS 150UL
>   #define Z_MAGIC_HIT_DELAY_MILLIS 500UL
>   millis_t z_magic_elasticity_min_timeout = 0UL;
>   millis_t z_magic_elasticity_max_timeout = 0UL;
>   millis_t z_magic_hit_timeout = 0UL;
>   millis_t z_magic_tap_timeout = 0UL;
>
>   int z_magic_value = 0;
>   int z_magic_hit_count = 0;
>
> inline void update_z_magic( ) {
>
>   raw_z_magic_value = ADC;
>   z_magic_value = raw_z_magic_value;
>
>   float z_magic_f = float( z_magic_value );
>
>   millis_t now = millis();
>
>   z_magic_derivative_bias = ( z_magic_f - z_magic_last_measures_avg ) / 2.0;
>
>   if ( ELAPSED(now, z_magic_hit_timeout) ) {
>     if ( z_magic_derivative_bias < -Z_MAGIC_DERIVATIVE_BIAS_THRESHOLD ) {
>       z_magic_hit_timeout = now + Z_MAGIC_EDGE_DELAY_MILLIS;
>       z_magic_elasticity_max_timeout = now + Z_MAGIC_MAX_ELASTICITY_RESPONSE_MILLIS;
>     }
>   }
>
>   if ( PENDING(now, z_magic_elasticity_max_timeout) ) {
>     if ( ELAPSED(now, z_magic_elasticity_min_timeout) ) {
>       if ( z_magic_derivative_bias > Z_MAGIC_DERIVATIVE_BIAS_THRESHOLD ) {
>         z_magic_elasticity_min_timeout = now + Z_MAGIC_EDGE_DELAY_MILLIS;
>         z_magic_tap_timeout = now + Z_MAGIC_HIT_DELAY_MILLIS;
>         z_magic_hit_count += 1;
>       }
>     }
>   }
>
>   if (ELAPSED(now, z_magic_tap_timeout)) {
>     z_magic_hit_count = 0;
>   }
>
>
>   // Update last_measures avg
>   z_magic_last_measures[ z_magic_last_measures_idx ] = z_magic_f;
>   z_magic_last_measures_idx = ( z_magic_last_measures_idx + 1 ) % Z_MAGIC_LAST_MEASURES_NUMBER;
>
>   z_magic_last_measures_avg = z_magic_last_measures[0];
>   for( int i=1; i<Z_MAGIC_LAST_MEASURES_NUMBER; i++ ) {
>     z_magic_last_measures_avg += z_magic_last_measures[ i ];
>   }
>   z_magic_last_measures_avg /= float( Z_MAGIC_LAST_MEASURES_NUMBER );
> }
>
> #endif
>
1635a1715,1717
>       #if ENABLED( Z_MIN_MAGIC )
>         can_measure_z_magic = false;
>       #endif
1641a1724,1726
>       #if ENABLED( Z_MIN_MAGIC )
>         can_measure_z_magic = false;
>       #endif
1649a1735,1738
>       #if ENABLED( Z_MIN_MAGIC )
>         can_measure_z_magic = true;
>         START_ADC(15);
>       #endif
1655a1745,1748
>       #if ENABLED( Z_MIN_MAGIC )
>         can_measure_z_magic = true;
>         update_z_magic();
>       #endif
1663a1757,1760
>       #if ENABLED( Z_MIN_MAGIC )
>         can_measure_z_magic = true;
>         START_ADC(15);
>       #endif
1669a1767,1770
>       #if ENABLED( Z_MIN_MAGIC )
>         can_measure_z_magic = true;
>         update_z_magic();
>       #endif
1677a1779,1782
>       #if ENABLED( Z_MIN_MAGIC )
>         can_measure_z_magic = true;
>         START_ADC(15);
>       #endif
1683a1789,1792
>       #if ENABLED( Z_MIN_MAGIC )
>         can_measure_z_magic = true;
>         update_z_magic();
>       #endif
1691a1801,1804
>       #if ENABLED( Z_MIN_MAGIC )
>         can_measure_z_magic = true;
>         START_ADC(15);
>       #endif
1697a1811,1814
>       #if ENABLED( Z_MIN_MAGIC )
>         can_measure_z_magic = true;
>         update_z_magic();
>       #endif
1705a1823,1826
>       #if ENABLED( Z_MIN_MAGIC )
>         can_measure_z_magic = true;
>         START_ADC(15);
>       #endif
1716a1838,1841
>       #if ENABLED( Z_MIN_MAGIC )
>         can_measure_z_magic = true;
>         update_z_magic();
>       #endif
diff Marlin/temperature.h ../DiscoEasy200/temperature.h
188a189,195
> #if ENABLED( Z_MIN_MAGIC )
>   extern bool can_measure_z_magic;
>   extern int z_magic_value;
>   extern float z_magic_derivative_bias;
>   extern int z_magic_hit_count;
> #endif
>
diff Marlin/thermistortables.h ../DiscoEasy200/thermistortables.h
1083a1084,1192
> #if (THERMISTORHEATER_0 == 16) || (THERMISTORHEATER_1 == 16) || (THERMISTORHEATER_2 == 16) || (THERMISTORHEATER_3 == 16) || (THERMISTORBED == 16)
> // 16 is 100K thermistor - Alternative ATC Semitec 104GT-2 (4.7k pullup) Dagoma.Fr version (measured/tested/approved)
> const short temptable_16[][2] PROGMEM = {
>   {5*OVERSAMPLENR,320},
>   {6*OVERSAMPLENR,310},
>   {7*OVERSAMPLENR,300},
>   {8*OVERSAMPLENR,295},
>   {10*OVERSAMPLENR,285},
>   {11*OVERSAMPLENR,280},
>   {12*OVERSAMPLENR,275},
>   {16*OVERSAMPLENR,265},
>   {20*OVERSAMPLENR,254},
>   {22*OVERSAMPLENR,250},
>   {29*OVERSAMPLENR,240},
>   {36*OVERSAMPLENR,230},
>   {45*OVERSAMPLENR,222},
>   {48*OVERSAMPLENR,215},
>   {52*OVERSAMPLENR,208},
>   {72*OVERSAMPLENR,202},
>   {75*OVERSAMPLENR,196},
>   {86*OVERSAMPLENR,192},
>   {89*OVERSAMPLENR,188},
>   {106*OVERSAMPLENR,182},
>   {120*OVERSAMPLENR,174},
>   {131*OVERSAMPLENR,170},
>   {143*OVERSAMPLENR,166},
>   {152*OVERSAMPLENR,162},
>   {168*OVERSAMPLENR,158},
>   {184*OVERSAMPLENR,153},
>   {203*OVERSAMPLENR,150},
>   {221*OVERSAMPLENR,145},
>   {240*OVERSAMPLENR,143},
>   {288*OVERSAMPLENR,134},
>   {343*OVERSAMPLENR,125},
>   {404*OVERSAMPLENR,116},
>   {479*OVERSAMPLENR,107},
>   {553*OVERSAMPLENR,98},
>   {629*OVERSAMPLENR,89},
>   {710*OVERSAMPLENR,78},
>   {781*OVERSAMPLENR,69},
>   {844*OVERSAMPLENR,60},
>   {892*OVERSAMPLENR,50},
>   {932*OVERSAMPLENR,41},
>   {970*OVERSAMPLENR,29},
>   {1000*OVERSAMPLENR,20},
>   {1010*OVERSAMPLENR,10},
>   {1024*OVERSAMPLENR,-273} // for safety
> };
> #endif
>
>
> #if (THERMISTORHEATER_0 == 17) || (THERMISTORHEATER_1 == 17) || (THERMISTORHEATER_2 == 17) || (THERMISTORHEATER_3 == 17) || (THERMISTORBED == 17)
> // 17 is 100K thermistor - Alternative ATC Semitec 104GT-2 (4.7k pullup) Dagoma.Fr - MKS_Base - version (measured/tested/approved)
> const short temptable_17[][2] PROGMEM = {
>   {16*OVERSAMPLENR,309},
>   {18*OVERSAMPLENR,307},
>   {20*OVERSAMPLENR,300},
>   {22*OVERSAMPLENR,293},
>   {26*OVERSAMPLENR,284},
>   {29*OVERSAMPLENR,272},
>   {33*OVERSAMPLENR,266},
>   {36*OVERSAMPLENR,260},
>   {42*OVERSAMPLENR,252},
>   {46*OVERSAMPLENR,247},
>   {48*OVERSAMPLENR,244},
>   {51*OVERSAMPLENR,241},
>   {62*OVERSAMPLENR,231},
>   {73*OVERSAMPLENR,222},
>   {78*OVERSAMPLENR,219},
>   {87*OVERSAMPLENR,212},
>   {98*OVERSAMPLENR,207},
>   {109*OVERSAMPLENR,201},
>   {118*OVERSAMPLENR,197},
>   {131*OVERSAMPLENR,191},
>   {145*OVERSAMPLENR,186},
>   {160*OVERSAMPLENR,181},
>   {177*OVERSAMPLENR,175},
>   {203*OVERSAMPLENR,169},
>   {222*OVERSAMPLENR,164},
>   {256*OVERSAMPLENR,156},
>   {283*OVERSAMPLENR,151},
>   {312*OVERSAMPLENR,145},
>   {343*OVERSAMPLENR,140},
>   {377*OVERSAMPLENR,131},
>   {413*OVERSAMPLENR,125},
>   {454*OVERSAMPLENR,119},
>   {496*OVERSAMPLENR,113},
>   {537*OVERSAMPLENR,108},
>   {578*OVERSAMPLENR,102},
>   {619*OVERSAMPLENR,97},
>   {658*OVERSAMPLENR,92},
>   {695*OVERSAMPLENR,87},
>   {735*OVERSAMPLENR,81},
>   {773*OVERSAMPLENR,75},
>   {808*OVERSAMPLENR,70},
>   {844*OVERSAMPLENR,64},
>   {868*OVERSAMPLENR,59},
>   {892*OVERSAMPLENR,54},
>   {914*OVERSAMPLENR,49},
>   {935*OVERSAMPLENR,42},
>   {951*OVERSAMPLENR,38},
>   {967*OVERSAMPLENR,32},
>   {975*OVERSAMPLENR,28},
>   {1000*OVERSAMPLENR,20},
>   {1010*OVERSAMPLENR,10},
>   {1024*OVERSAMPLENR,-273} // for safety
> };
> #endif
>
Seulement dans ../DiscoEasy200/: .travis.yml
diff Marlin/ultralcd.cpp ../DiscoEasy200/ultralcd.cpp
50a51,54
> #if ENABLED( AUTO_BED_LEVELING_FEATURE )
>   #define Z_OFFSET_REINIT_START_VALUE (-4.0f)
> #endif
>
98a103,106
>   #if ENABLED(AUTO_BED_LEVELING_FEATURE)
>     static void lcd_set_z_offsets();
>   #endif
>   static void lcd_prepare_advanced_menu();
269a278,281
>   #if ENABLED(HAS_SERVO_ENDSTOPS) && ENABLED(Z_DUAL_ENDSTOPS)
>     float z_probed_value_before_z_raise;
>   #endif
>
693a706
>
749c762,766
<      MENU_ITEM(gcode, MSG_FILAMENTCHANGE, PSTR("M600"));
---
>     #if ENABLED(SUMMON_PRINT_PAUSE)
>       MENU_ITEM(gcode, MSG_FILAMENTCHANGE, PSTR(FILAMENT_RUNOUT_SCRIPT));
>     #else
>       MENU_ITEM(gcode, MSG_FILAMENTCHANGE, PSTR("M600 PA"));
>     #endif
875a893,954
> void lcd_parallel_x(){
>   lcd_return_to_status();
>
>   enqueue_and_echo_commands_P( PSTR("M117 Origine Machine") );  // ; Message sur afficheur
>   enqueue_and_echo_commands_P( PSTR("M84") );  //                  ; Disable motors to encure Z_SAFE_HOMING
>   #if ENABLED(Z_DUAL_ENDSTOPS)
>     enqueue_and_echo_commands_P( PSTR("M666 Z0") );
>   #endif
>   enqueue_and_echo_commands_P( PSTR("G28") );  //             	   ; Home X Y Z
>   enqueue_and_echo_commands_P( PSTR("G90") );  //                	 ; Passage coordonnees absolues
>   wait_all_commands_finished__CALLABLE_FROM_LCD_ONLY();
>
>   //;Parallelisme Axe X
>   enqueue_and_echo_commands_P( PSTR("M117 Parallelisme X") );  //      ; Message sur afficheur
>   #if DISABLED(Z_DUAL_ENDSTOPS)
>     enqueue_and_echo_commands_P( PSTR("G1 Z5 F9000") );  //           ; lift nozzle
>     wait_all_commands_finished__CALLABLE_FROM_LCD_ONLY();
>
>     enqueue_and_echo_commands_P( PSTR("G1 X-24 Y-14 F9000") );  //
>     enqueue_and_echo_commands_P( PSTR("G92 Z20") );  //
>     enqueue_and_echo_commands_P( PSTR("G91") );  //                   ; Passage coordonnees relatives
>     wait_all_commands_finished__CALLABLE_FROM_LCD_ONLY();
>
>     enqueue_and_echo_commands_P( PSTR("G1 Z-15 F200") );  //		     ; Descente en dessous du plateau
>     enqueue_and_echo_commands_P( PSTR("G1 Z15 F9000") );  //
>     enqueue_and_echo_commands_P( PSTR("G28") );  //		            ; Home
>     wait_all_commands_finished__CALLABLE_FROM_LCD_ONLY();
>   #else
>     enqueue_and_echo_commands_P( PSTR("G1 X0 F9000") );
>     enqueue_and_echo_commands_P( PSTR("G30") );
>     wait_all_commands_finished__CALLABLE_FROM_LCD_ONLY();
>
>     float z_left, z_right, z_diff;
>     #if ENABLED(HAS_SERVO_ENDSTOPS)
>       z_left = z_probed_value_before_z_raise;
>     #else
>       z_left = current_position[ Z_AXIS ];
>     #endif
>
>     enqueue_and_echo_commands_P( PSTR("G1 X350 F9000") );
>     enqueue_and_echo_commands_P( PSTR("G30") );
>     wait_all_commands_finished__CALLABLE_FROM_LCD_ONLY();
>
>
>     #if ENABLED(HAS_SERVO_ENDSTOPS)
>       z_right = z_probed_value_before_z_raise;
>     #else
>       z_right = current_position[ Z_AXIS ];
>     #endif
>
>     z_diff = z_right - z_left;
>     z_endstop_adj = z_diff;
>
>     enqueue_and_echo_commands_P( PSTR("G28") );
>     enqueue_and_echo_commands_P( PSTR("M666 Z0") );
>     wait_all_commands_finished__CALLABLE_FROM_LCD_ONLY();
>
>   #endif // Z_DUAL_ENDSTOPS
>
>   enqueue_and_echo_commands_P( PSTR("G90") );  //                   ; Passage coordonnees absolues
> }
>
1081a1161,1164
>   /**
>    * Step 1: MBL entry-point: "Cancel" or "Level Bed"
>    */
>
1089a1173,1181
>  //Préparer
>    // Déplacer un axes
>    // Préchanffage PLA
>    // Réglage Offset
>    // Refroidir
>    // Eteindre alim.
>    // Tout le reste : Réglages avancés
>      // Préchauffage ABS
>
1097a1190
>
1099c1192
<   // Auto Home
---
>   // Move Axis
1101c1194
<   MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
---
>   MENU_ITEM(submenu, MSG_MOVE_AXIS, lcd_move_menu);
1104c1197,1198
<   // Set Home Offsets
---
>   // Preheat PLA
>   // Preheat ABS
1106,1107c1200,1210
<   MENU_ITEM(function, MSG_SET_HOME_OFFSETS, lcd_set_home_offsets);
<   //MENU_ITEM(gcode, MSG_SET_ORIGIN, PSTR("G92 X0 Y0 Z0"));
---
>   #if TEMP_SENSOR_0 != 0
>     #if TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_3 != 0 || TEMP_SENSOR_BED != 0
>       MENU_ITEM(submenu, MSG_PREHEAT_PLA, lcd_preheat_pla_menu);
>     #else
>       MENU_ITEM(function, MSG_PREHEAT_PLA, lcd_preheat_pla0);
>     #endif
>   #endif
>
>   #if ENABLED(PARALLEL_X_FEATURE)
>     MENU_ITEM(function, MSG_PARALLEL_X, lcd_parallel_x);
>   #endif
1113,1117c1216
<     MENU_ITEM(gcode, MSG_LEVEL_BED,
<       axis_homed[X_AXIS] && axis_homed[Y_AXIS] ? PSTR("G29") : PSTR("G28\nG29")
<     );
<   #elif ENABLED(MANUAL_BED_LEVELING)
<     MENU_ITEM(submenu, MSG_LEVEL_BED, lcd_level_bed);
---
>     MENU_ITEM(submenu, MSG_Z_OFFSET, lcd_set_z_offsets);
1119a1219
>
1121c1221
<   // Move Axis
---
>   // Cooldown
1123c1223
<   MENU_ITEM(submenu, MSG_MOVE_AXIS, lcd_move_menu);
---
>   MENU_ITEM(function, MSG_COOLDOWN, lcd_cooldown);
1126c1226
<   // Disable Steppers
---
>   // Switch power on/off
1128c1228,1261
<   MENU_ITEM(gcode, MSG_DISABLE_STEPPERS, PSTR("M84"));
---
>   #if HAS_POWER_SWITCH
>     if (powersupply)
>       MENU_ITEM(gcode, MSG_SWITCH_PS_OFF, PSTR("M81"));
>     else
>       MENU_ITEM(gcode, MSG_SWITCH_PS_ON, PSTR("M80"));
>   #endif
>
>   MENU_ITEM(submenu, MSG_PREPARE_ADVENCED, lcd_prepare_advanced_menu);
>
>   END_MENU();
> }
>
> static void lcd_prepare_advanced_menu() {
>   START_MENU();
>
>   //
>   // ^ Main
>   //
>   MENU_ITEM(back, MSG_MAIN);
>   //
>   // Auto Home
>   //
>   MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
>
>   //
>   // Level Bed
>   //
>   #if ENABLED(AUTO_BED_LEVELING_FEATURE)
>     MENU_ITEM(gcode, MSG_LEVEL_BED,
>       axis_homed[X_AXIS] && axis_homed[Y_AXIS] ? PSTR("G29") : PSTR("G28\nG29")
>     );
>   #elif ENABLED(MANUAL_BED_LEVELING)
>     MENU_ITEM(submenu, MSG_LEVEL_BED, lcd_level_bed);
>   #endif
1136d1268
<       MENU_ITEM(submenu, MSG_PREHEAT_PLA, lcd_preheat_pla_menu);
1139d1270
<       MENU_ITEM(function, MSG_PREHEAT_PLA, lcd_preheat_pla0);
1145c1276
<   // Cooldown
---
>   // Set Home Offsets
1147c1278,1279
<   MENU_ITEM(function, MSG_COOLDOWN, lcd_cooldown);
---
>   MENU_ITEM(function, MSG_SET_HOME_OFFSETS, lcd_set_home_offsets);
>   //MENU_ITEM(gcode, MSG_SET_ORIGIN, PSTR("G92 X0 Y0 Z0"));
1150c1282
<   // Switch power on/off
---
>   // Disable Steppers
1152,1157c1284
<   #if HAS_POWER_SWITCH
<     if (powersupply)
<       MENU_ITEM(gcode, MSG_SWITCH_PS_OFF, PSTR("M81"));
<     else
<       MENU_ITEM(gcode, MSG_SWITCH_PS_ON, PSTR("M80"));
<   #endif
---
>   MENU_ITEM(gcode, MSG_DISABLE_STEPPERS, PSTR("M84"));
1205a1333,1366
>
> static void _lcd_move_callback(const char* name, AxisEnum axis, float min, float max, menuFunc_t callback) {
>   ENCODER_DIRECTION_NORMAL();
>   if (encoderPosition && movesplanned() <= 3) {
>     refresh_cmd_timeout();
>     current_position[axis] += float((int32_t)encoderPosition) * move_menu_scale;
>     if (min_software_endstops) NOLESS(current_position[axis], min);
>     if (max_software_endstops) NOMORE(current_position[axis], max);
>     line_to_current(axis);
>     lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
>   }
>   encoderPosition = 0;
>   if (lcdDrawUpdate) lcd_implementation_drawedit(name, ftostr31(current_position[axis]));
>   if (LCD_CLICKED) (*callback)();
> }
>
> #if ENABLED( AUTO_BED_LEVELING_FEATURE )
>   static void _lcd_move_callback_with_offset(const char* name, AxisEnum axis, float min, float max, menuFunc_t callback, float offset) {
>     ENCODER_DIRECTION_NORMAL();
>     if (encoderPosition && movesplanned() <= 3) {
>       refresh_cmd_timeout();
>       current_position[axis] += float((int32_t)encoderPosition) * move_menu_scale;
>       if (min_software_endstops) NOLESS(current_position[axis], min);
>       if (max_software_endstops) NOMORE(current_position[axis], max);
>       line_to_current(axis);
>       lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
>     }
>     encoderPosition = 0;
>     if (lcdDrawUpdate) lcd_implementation_drawedit(name, ftostr32(current_position[axis] + offset));
>     if (LCD_CLICKED) (*callback)();
>   }
> #endif
>
>
1215c1376
< static void lcd_move_z() { _lcd_move(PSTR(MSG_MOVE_Z), Z_AXIS, sw_endstop_min[Z_AXIS], sw_endstop_max[Z_AXIS]); }
---
> static void lcd_move_z() { _lcd_move(PSTR(MSG_MOVE_Z), Z_AXIS, sw_endstop_min[Z_AXIS], sw_endstop_max[Z_AXIS]); SERIAL_ERRORLN("lcdZConf"); }
1317a1479,1596
> #if ENABLED( AUTO_BED_LEVELING_FEATURE )
>
> static void _lcd_reinit_z_offsets_saved(){
>   START_MENU();
>
>   MENU_ITEM_DUMMY();
>   MENU_ITEM_DUMMY();
>   MENU_ITEM_DUMMY();
>   MENU_ITEM_DUMMY();
>
>   lcd_implementation_drawmenu_generic(0, 1, PSTR(MSG_PARAMETERS), ' ', ' ');
>   lcd_implementation_drawmenu_generic(0, 2, PSTR(MSG_SAVED), ' ', ' ');
>
>   encoderLine = 4;
>   MENU_ITEM(submenu, MSG_LCD_OK, lcd_return_to_status);
>
>
>   END_MENU();
> }
>
> static void _lcd_reinit_z_offsets_wait(){
>   START_MENU();
>
>   lcd_implementation_drawmenu_generic(0, 2, PSTR(MSG_WAIT), ' ', ' ');
>
>   END_MENU();
> }
>
> static void _lcd_reinit_z_offsets_save_back(){
>   lcd_goto_menu(_lcd_reinit_z_offsets_wait);
>
>   zprobe_zoffset = Z_OFFSET_REINIT_START_VALUE + current_position[Z_AXIS];
>
>   Config_StoreSettings();
>   enqueue_and_echo_commands_P(PSTR("M84"));   // ; Disable motors to encure Z_SAFE_HOMING
>   enqueue_and_echo_commands_P(PSTR("G28"));   // origine auto : besoin pour que le z soit pris en compte
>   enqueue_and_echo_commands_P(PSTR("G0 Z0")); //
>
>   wait_all_commands_finished__CALLABLE_FROM_LCD_ONLY();
>
>   defer_return_to_status = false;
>   lcd_goto_menu(_lcd_reinit_z_offsets_saved);
> }
>
> static void _lcd_reinit_z_offsets_zConfig(){
>
>   lcd_implementation_drawmenu_generic(0, 0, PSTR(MSG_PINCH), ' ', ' ');
>   lcd_implementation_drawmenu_generic(0, 1, PSTR(MSG_SET_OFFSET), ' ', ' ');
>
>   //lcd_move_z();
>   move_menu_scale = 0.05;
>   _lcd_move_callback_with_offset(PSTR(MSG_MOVE_Z), Z_AXIS, sw_endstop_min[Z_AXIS], sw_endstop_max[Z_AXIS], _lcd_reinit_z_offsets_save_back, Z_OFFSET_REINIT_START_VALUE);
>
>   lcd_implementation_drawmenu_generic(0, 4, PSTR(MSG_VALIDATE), ' ', ' ');
> }
>
>
> static void _lcd_reinit_z_offsets_screenSheet(){
>   START_MENU();
>
>   MENU_ITEM_DUMMY();
>   MENU_ITEM_DUMMY();
>   MENU_ITEM_DUMMY();
>   MENU_ITEM_DUMMY();
>
>   lcd_implementation_drawmenu_generic(0, 0, PSTR(MSG_ADD_SHEET), ' ', ' ');
>   lcd_implementation_drawmenu_generic(0, 1, PSTR(MSG_BESIDE_NOZZLE), ' ', ' ');
>   lcd_implementation_drawmenu_generic(0, 2, PSTR(MSG_CLICK_OK), ' ', ' ');
>   //_drawLineNr = 3;
>   encoderLine = 4;
>   MENU_ITEM(submenu, "OK", _lcd_reinit_z_offsets_zConfig);
>
>   END_MENU();
> }
>
> //1 écran : Placez la feuille et validez
> //2 écran : Pincez la feuille
>
> //si décalage : vérifier BED_CENTER_AT_0_0 n'est pas define dans la conf
>
> static void lcd_reinit_z_offsets(){
>   lcd_goto_menu(_lcd_reinit_z_offsets_wait);
>
>   defer_return_to_status = true;
>
>   zprobe_zoffset = Z_OFFSET_REINIT_START_VALUE;
>   Config_StoreSettings();
>   enqueue_and_echo_commands_P(PSTR("M84"));  // ; Disable motors to encure Z_SAFE_HOMING
>   enqueue_and_echo_commands_P(PSTR("G28"));  // origine auto
>   wait_all_commands_finished__CALLABLE_FROM_LCD_ONLY();
>
>   lcd_goto_menu(_lcd_reinit_z_offsets_screenSheet);
> }
>
> static void lcd_set_z_offsets_save_config() {
>   Config_StoreSettings();
>   enqueue_and_echo_commands_P(PSTR("M84"));   // ; Disable motors to encure Z_SAFE_HOMING
>   enqueue_and_echo_commands_P(PSTR("G28"));
>   enqueue_and_echo_commands_P(PSTR("G0 Z0")); // origine auto : besoin pour que le z soit pris en compte
> }
>
> static void lcd_set_z_offsets() {
>   START_MENU();
>   MENU_ITEM(back, MSG_PREPARE);
>
>   MENU_ITEM(function, "Reinitialiser", lcd_reinit_z_offsets);
>   //zprobe_zoffset = -4.0;
>   //Config_StoreSettings();
>   //enqueue_and_echo_commands_P(PSTR("G28")); //origine auto
>   //lcd_move_z();
>
>   MENU_ITEM_EDIT_CALLBACK(float32, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX, lcd_set_z_offsets_save_config);
>
>   END_MENU();
> }
>
> #endif
>
1493c1772
<   #if FAN_COUNT > 0
---
>   #if (FAN_COUNT > 0) && (DISABLED (IS_MONO_FAN))
diff Marlin/ultralcd.h ../DiscoEasy200/ultralcd.h
87a88,91
>
>   #if ENABLED(HAS_SERVO_ENDSTOPS) && ENABLED(Z_DUAL_ENDSTOPS)
>     extern float z_probed_value_before_z_raise;
>   #endif
