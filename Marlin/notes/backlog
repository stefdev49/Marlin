diff Marlin/Marlin_main.cpp ../DiscoEasy200/Marlin_main.cpp
404a425,426
>   #define SIN_30 COS_60
>   #define COS_30 SIN_60
426a449,457
>
>   #if ENABLED( DELTA_EXTRA )
>     bool postcompute_tri_ready = false;
>     bool startup_auto_calibration = false;
>     float z_smooth_tri_leveling_height = 0.0;
>     #if ENABLED( SDSUPPORT )
>       inline void abort_sd_printing();
>     #endif
>   #endif
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
1086a1344
>           #if DISABLED(ONE_BUTTON)
1087a1346
>           #endif
1089,1091d1347
<         if (sd_char == '#') stop_buffering = true;
<
<         sd_comment_mode = false; //for new command
1094,1098d1349
<
<         command_queue[cmd_queue_index_w][sd_count] = '\0'; //terminate string
<         sd_count = 0; //clear buffer
<
<         _commit_command(false);
1537c1788,1818
<   static void run_z_probe() {
---
>   // Check if pause is triggered during G29 (manuel bed leveling) and D851 (custom calibration)
>   #if ENABLED(EMERGENCY_STOP)
>     void handle_emergency_stop(){
>       if ( trigger_emergency_stop ) {
>         // Abort current operations:
>         // - Move the nozzle up
>         #if ENABLED(EMERGENCY_STOP_Z_MOVE)
>           // Setting the current_position seems useless as the move is stopped by resetting...?
>           //current_position[Z_AXIS] += 5;
>           feedrate = homing_feedrate[Z_AXIS];
>           #if ENABLED(DELTA)
>             calculate_delta(current_position);
>             plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS], feedrate / 60, active_extruder);
>           #else
>             line_to_current_position();
>           #endif
>         #endif
>         // - Reset the board
>         while( true ) {
>           #if ENABLED(ONE_LED)
>             one_led_on();
>             delay(150);
>             one_led_off();
>           #endif
>           delay(150);
>         }
>       }
>     }
>   #endif
>
>   static void run_z_probe(bool fast=false) {
1555,1556c1836,1846
<       feedrate = homing_feedrate[Z_AXIS] / 4;
<       destination[Z_AXIS] = -10;
---
>       #if ENABLED(DELTA_EXTRA)
>         if (fast) {
>           feedrate = homing_feedrate[Z_AXIS] / 2;
>         }
>         else {
>       #endif
>           feedrate = homing_feedrate[Z_AXIS] / 4;
>       #if ENABLED(DELTA_EXTRA)
>         }
>       #endif
>       destination[Z_AXIS] = -20;
1558a1849,1851
>       #if ENABLED(EMERGENCY_STOP)
>         handle_emergency_stop();
>       #endif
1575a1869,1871
>       #if ENABLED(DEBUG_LEVELING_FEATURE)
>         SERIAL_ECHOLN("run_z_probe (DISCO)");
>       #endif
1583a1880,1882
>       #if ENABLED(EMERGENCY_STOP)
>         handle_emergency_stop();
>       #endif
1595a1895,1897
>       #if ENABLED(EMERGENCY_STOP)
>         handle_emergency_stop();
>       #endif
1603a1906,1908
>       #if ENABLED(EMERGENCY_STOP)
>         handle_emergency_stop();
>       #endif
3075a3381,3859
>   #if ENABLED( DELTA_EXTRA )
>
>     #define PROBE_POINT_NUMBER 19 // 12 outer, 6 inner, 1 center
>     // Numbered from X tower cardinal axis,
>     // from outside to center
>     // Contains constant X,Y probe point,
>     // thrid and last float room will contain probed altitude
>     float probe_plan[PROBE_POINT_NUMBER][3] = {
>       // Outer
>       {
>         delta_tower1_x,
>         delta_tower1_y,
>         0.0
>       },
>       {
>         -COS_60 * delta_radius,
>         -SIN_60 * delta_radius,
>         0.0
>       },
>       {
>         0.0,
>         -1.0 * delta_radius,
>         0.0
>       },
>       {
>         COS_60 * delta_radius,
>         -SIN_60 * delta_radius,
>         0.0
>       },
>       {
>         delta_tower2_x,
>         delta_tower2_y,
>         0.0
>       },
>       {
>         delta_radius,
>         0.0,
>         0.0
>       },
>       {
>         SIN_60 * delta_radius,
>         COS_60 * delta_radius,
>         0.0
>       },
>       {
>         COS_60 * delta_radius,
>         SIN_60 * delta_radius,
>         0.0
>       },
>       {
>         delta_tower3_x,
>         delta_tower3_y,
>         0.0
>       },
>       {
>         -COS_60 * delta_radius,
>         SIN_60 * delta_radius,
>         0.0
>       },
>       {
>         -SIN_60 * delta_radius,
>         COS_60 * delta_radius,
>         0.0
>       },
>       {
>         -delta_radius,
>         0.0,
>         0.0
>       },
>       // Inner
>       {
>         -SIN_60 * delta_radius / 2.0,
>         -COS_60 * delta_radius / 2.0,
>         0.0
>       },
>       {
>         0.0,
>         -delta_radius / 2.0,
>         0.0
>       },
>       {
>         SIN_60 * delta_radius / 2.0,
>         -COS_60 * delta_radius / 2.0,
>         0.0
>       },
>       {
>         SIN_60 * delta_radius / 2.0,
>         COS_60 * delta_radius / 2.0,
>         0.0
>       },
>       {
>         0.0,
>         delta_radius / 2.0,
>         0.0
>       },
>       {
>         -SIN_60 * delta_radius / 2.0,
>          COS_60 * delta_radius / 2.0,
>         0.0
>       },
>       // Center
>       {
>         0.0,
>         0.0,
>         0.0
>       }
>     };
>
>     // As probe_plan above,
>     // numbered from X tower cardinal axis
>     // From outside to center
>     #define PROBE_MESH_NUMBER 24
>     const short probe_plan_mesh[PROBE_MESH_NUMBER][3] = {
>       // Outer (one side outer) (12)
>       { 0, 1, 12 },
>       { 1, 2, 13 },
>       { 2, 3, 13 },
>       { 3, 4, 14 },
>       { 4, 5, 14 },
>       { 5, 6, 15 },
>       { 7, 6, 15 },
>       { 7, 8, 16 },
>       { 8, 9, 16 },
>       { 9, 10, 17 },
>       { 10, 11, 17 },
>       { 11, 0, 12 },
>       // Outer (one point outer) (6)
>       { 1, 13, 12 },
>       { 3, 14, 13 },
>       { 5, 15, 14 },
>       { 7, 16, 15 },
>       { 9, 17, 16 },
>       { 11, 12, 17 },
>       // Inner (6)
>       { 12, 13, 18 },
>       { 13, 14, 18 },
>       { 14, 15, 18 },
>       { 15, 16, 18 },
>       { 16, 17, 18 },
>       { 17, 12, 18 }
>     };
>
>     // Predefine used functions
>     inline void gcode_M500();
>     inline void gcode_M665();
>     inline void gcode_G30(bool fast=false);
>
>     #define Z_AVG_TOLERANCE 0.02
>
>     inline float get_probed_Z_avg(bool fast=false) {
>
>       bool all_points_are_good = false;
>       float z_read[3] = { 50.0 };
>       float z_avg = 0.0;
>
>       do {
>         gcode_G30(fast);
>
>         z_read[2] = z_read[1];
>         z_read[1] = z_read[0];
>         z_read[0] = current_position[Z_AXIS];
>
>         if (fast) {
>           z_avg = ( z_read[0] + z_read[1] ) / 2.0;
>         }
>         else {
>           z_avg = ( z_read[0] + z_read[1] + z_read[2] ) / 3.0;
>         }
>
>         set_destination_to_current();
>         destination[ Z_AXIS ] = min( 50.0, destination[ Z_AXIS ] + 5.0 );
>         prepare_move();
>         st_synchronize();
>
>         if ( destination[ Z_AXIS ] > 49.90 ) {
>           int i=10; do { idle(true); delay(100); } while(--i);
>           all_points_are_good = false;
>         }
>         else {
>           // Check for all points
>           all_points_are_good =
>             abs(z_read[0] - z_avg) < Z_AVG_TOLERANCE &&
>             abs(z_read[1] - z_avg) < Z_AVG_TOLERANCE &&
>             abs(z_read[2] - z_avg) < Z_AVG_TOLERANCE;
>         }
>
>       } while( !all_points_are_good );
>
>
>       return z_avg;
>     }
>
>     /**
>      *           T3
>      *           |
>      *           |
>      *          4| 3
>      *           |
>      *      ZX   O    YZ
>      *        5      2
>      *
>      *         0    1
>      *
>      *  T1       XY        T2
>      */
>
>     float triangle_sign(const float x, const float y, const short p1, const short p2) {
>       return
>         (x - probe_plan[p2][0]) * (probe_plan[p1][1] - probe_plan[p2][1]) -
>         (probe_plan[p1][0] - probe_plan[p2][0]) * (y - probe_plan[p2][1]);
>     }
>
>     bool triangle_contains(const float x, const float y, const short t) {
>       bool b1, b2, b3;
>
>       const short *triangle;
>       triangle = probe_plan_mesh[t];
>
>       b1 = triangle_sign(x, y, triangle[0], triangle[1]) <= 0.0;
>       b2 = triangle_sign(x, y, triangle[1], triangle[2]) <= 0.0;
>       b3 = triangle_sign(x, y, triangle[2], triangle[0]) <= 0.0;
>
>       return ((b1 == b2) && (b2 == b3));
>     }
>
>     #define PROBE_REGION_NUMBER 12
>     const short probe_plan_triangle_mesh_region[PROBE_REGION_NUMBER][4] = {
>       { 18, 12, 0 },
>       { 18, 12, 1 },
>       { 19, 13, 2 },
>       { 19, 13, 3 },
>       { 20, 14, 4 },
>       { 20, 14, 5 },
>       { 21, 15, 6 },
>       { 21, 15, 7 },
>       { 22, 16, 8 },
>       { 22, 16, 9 },
>       { 23, 17, 10 },
>       { 23, 17, 11 }
>     };
>
>     // TODO: Move it to the right place
>     // WHERE: on calculate_delta parameters ?
>     // 'CAUSE: these values are fixed against delta R
>     float precalc_probe_plan_region_aref[8] = { 0.0 };
>
>     inline short triangle_index_in_region( const float x, const float y, const short r ) {
>       const short *region;
>       region = probe_plan_triangle_mesh_region[r];
>
>       if ( triangle_contains(x, y, region[0]) ) return region[0];
>       if ( triangle_contains(x, y, region[1]) ) return region[1];
>
>       return region[2];
>     };
>
>     inline short region_index( const float x, const float y ) {
>
>       // While all tri equations are just: y = a.x;
>       float aTested = y / x;
>
>       // Simple test to choice between 2 region groups: 2,3,4,5,6,7 or 8,9,10,11,0,1
>       if ( x >= 0.0 ) {
>         // Region is one of 2,3,4,5,6,7
>
>         // Simple test to choice between 2 sub region groups: 5,6,7 or 2,3,4
>         if (y >= 0.0 ) {
>           // Region is one of 5,6,7
>           if ( aTested > precalc_probe_plan_region_aref[4] ) {
>             // Region is one of 6, 7
>             if ( aTested > precalc_probe_plan_region_aref[5] ) {
>               return 7;
>             }
>             else {
>               return 6;
>             }
>           }
>           else {
>             return 5;
>           }
>         }
>         else {
>           // Region is one of 2,3,4
>           if ( aTested > precalc_probe_plan_region_aref[2] ) {
>             // Region is one of 3,4
>             if ( aTested > precalc_probe_plan_region_aref[3] ) {
>               return 4;
>             }
>             else {
>               return 3;
>             }
>           }
>           else {
>             return 2;
>           }
>         }
>       }
>       else {
>         // Region is one of 8,9,10,11,0,1
>
>         // Simple test to choice between 2 sub region groups: 8,9,10 or 11,0,1
>         if (y >= 0.0 ) {
>           // Region is one of 8,9,10
>           if ( aTested > precalc_probe_plan_region_aref[6] ) {
>             // Region is one of 9,10
>             if ( aTested > precalc_probe_plan_region_aref[7] ) {
>               return 10;
>             }
>             else {
>               return 9;
>             }
>           }
>           else {
>             return 8;
>           }
>         }
>         else {
>           // Region is one of 11,0,1
>           if ( aTested > precalc_probe_plan_region_aref[0] ) {
>             // Region is one of 0,1
>             if ( aTested > precalc_probe_plan_region_aref[1] ) {
>               return 1;
>             }
>             else {
>               return 0;
>             }
>           }
>           else {
>             return 11;
>           }
>         }
>       }
>
>       // At this point, it's an error
>       // but do not mess up print with 'index out of bound'
>       return 0;
>     }
>
>     inline short triangle_index( const float x, const float y ) {
>       short r = region_index( x, y );
>       return triangle_index_in_region( x, y, r );
>     }
>
>     float probed_tri_postcompute_a[PROBE_MESH_NUMBER] = { 0.0 };
>     float probed_tri_postcompute_b[PROBE_MESH_NUMBER] = { 0.0 };
>     float probed_tri_postcompute_c[PROBE_MESH_NUMBER] = { 0.0 };
>     float probed_tri_postcompute_d[PROBE_MESH_NUMBER] = { 0.0 };
>
>     inline void probing_postcompute_tri_parameters() {
>
>
>       // Plane equation: a.x+b.y+c.z+d = 0
>       // Query to find z for given x,y will be
>       // z = (-d - b.y - a.x ) / c;
>       // z = -d/c - b.y/c - a.x/c;
>       // z = - (d + b.y + a.x) / c ;
>       // z = - (L/c + M/c + N/c);
>       // if
>       //   L = d/c
>       //   M = b/c
>       //   N = a/c
>
>
>       //   C
>       //   ^
>       // AC|
>       //   |
>       //   A ----> B
>       //      AB
>
>       float *A;
>       float *B;
>       float *C;
>
>       #define X 0
>       #define Y 1
>       #define Z 2
>
>       int i;
>       for(i=0; i < PROBE_MESH_NUMBER; i++) {
>         A = probe_plan[probe_plan_mesh[i][0]];
>         B = probe_plan[probe_plan_mesh[i][1]];
>         C = probe_plan[probe_plan_mesh[i][2]];
>         float a = ( B[Y]-A[Y] )*( C[Z]-A[Z] ) - ( C[Y]-A[Y] )*( B[Z]-A[Z] );
>         float b = ( B[Z]-A[Z] )*( C[X]-A[X] ) - ( C[Z]-A[Z] )*( B[X]-A[X] );
>         float c = ( B[X]-A[X] )*( C[Y]-A[Y] ) - ( C[X]-A[X] )*( B[Y]-A[Y] );
>         float d = -(a*A[X]+b*A[Y]+c*A[Z]);
>
>         float l = d/c;
>         float m = b/c;
>         float n = a/c;
>
>         probed_tri_postcompute_a[i] = a;
>         probed_tri_postcompute_b[i] = b;
>         probed_tri_postcompute_c[i] = c;
>         probed_tri_postcompute_d[i] = d;
>
>       }
>
>       // For memory:
>       // precalc_probed_tri_aref[ 0 ] = delta_tower2_y / delta_tower2_x;
>       // precalc_probed_tri_aref[ 1 ] = probe_point_YZ_y / probe_point_YZ_x;
>       // precalc_probed_tri_aref[ 2 ] = delta_tower1_y / delta_tower1_x;
>       // precalc_probed_tri_aref[ 3 ] = probe_point_ZX_y / probe_point_ZX_x;
>
>       precalc_probe_plan_region_aref[ 0 ] = probe_plan[ 0][1] / probe_plan[ 0][0];
>       precalc_probe_plan_region_aref[ 1 ] = probe_plan[ 1][1] / probe_plan[ 1][0];
>       precalc_probe_plan_region_aref[ 2 ] = probe_plan[ 3][1] / probe_plan[ 3][0];
>       precalc_probe_plan_region_aref[ 3 ] = probe_plan[ 4][1] / probe_plan[ 4][0];
>       precalc_probe_plan_region_aref[ 4 ] = probe_plan[ 6][1] / probe_plan[ 6][0];
>       precalc_probe_plan_region_aref[ 5 ] = probe_plan[ 7][1] / probe_plan[ 7][0];
>       precalc_probe_plan_region_aref[ 6 ] = probe_plan[ 9][1] / probe_plan[ 9][0];
>       precalc_probe_plan_region_aref[ 7 ] = probe_plan[10][1] / probe_plan[10][0];
>
>       postcompute_tri_ready = true;
>     }
>
>     inline void gcode_G29() {
>
>       postcompute_tri_ready = false;
>
>       gcode_G28();
>
>       feedrate = homing_feedrate[ X_AXIS ];
>
>       int i;
>       // Reset
>       for(i=0; i<PROBE_POINT_NUMBER; i++) {
>         probe_plan[i][2] = 42.0;
>       }
>
>       // Probing
>       for(i=0; i<PROBE_POINT_NUMBER; i++) {
>         destination[ X_AXIS ] = probe_plan[i][0];
>         destination[ Y_AXIS ] = probe_plan[i][1];
>         destination[ Z_AXIS ] = 10.0;
>         prepare_move();
>         st_synchronize();
>         probe_plan[i][2] = get_probed_Z_avg();
>       }
>
>       #if ENABLED(DEBUG_LEVELING_FEATURE)
>         if (DEBUGGING(LEVELING)) {
>           SERIAL_ECHOLNPGM("Probed tri altitude:");
>           for(i=0; i<PROBE_POINT_NUMBER; i++) {
>             SERIAL_ECHOPGM("               [" );
>             if(i<10) SERIAL_ECHOPGM( "0" );
>             SERIAL_ECHO( i );
>             SERIAL_ECHOPGM("]: ");
>             SERIAL_ECHOLN( probe_plan[i][2] );
>           }
>         }
>       #endif
>
>       z_smooth_tri_leveling_height = 20.0;
>
>       probing_postcompute_tri_parameters();
>
>
>       //#define TEST_SPECIAL_PROBE
>       #ifdef TEST_SPECIAL_PROBE
>
>         for( float y=-100.0; y < 100.0; y+= 10.0 ) {
>           for( float x=-100.0; x < 100.0; x+= 10.0 ) {
>             SERIAL_ECHO( "  @X:" );
>             SERIAL_ECHO( x );
>             SERIAL_ECHO( " Y:" );
>             SERIAL_ECHO( y );
>             SERIAL_ECHO( "  triangle_index:" );
>             SERIAL_ECHOLN( triangle_index( x, y ) );
>           }
>         }
>
>       #endif
>
>     }
>
>   #else // ELSE: !DELTA_EXTRA
>
3237a4022,4024
>     #if ENABLED(EMERGENCY_STOP)
>       handle_emergency_stop();
>     #endif
3601a4389,4390
>   #endif // END !DELTA_EXTRA
>
3606a4396,4398
>     #if ENABLED(DELTA_EXTRA)
>     inline void gcode_G30(bool fast/*default is declared above*/) {
>     #else
3607a4400
>     #endif
3619c4412,4416
<       run_z_probe();
---
>       #if ENABLED(DELTA_EXTRA)
>         run_z_probe(fast);
>       #else
>         run_z_probe();
>       #endif
3627a4425
>
3630a4429,4431
>         #if ENABLED(Z_DUAL_ENDSTOPS)
>           z_probed_value_before_z_raise = current_position[Z_AXIS];
>         #endif
5994a6796,6797
>
>
5996a6800,6891
>   // Generally :
>   //   homing_feedrate is expressed in mm/min
>   //   max_feedrate is expressed in mm/s
>   #if ENABLED(DELTA)
>     #define SET_FEEDRATE_FOR_MOVE          feedrate = homing_feedrate[X_AXIS] / 60.0;
>     #define SET_FEEDRATE_FOR_EXTRUDER_MOVE feedrate = max_feedrate[E_AXIS];
>     // The following plan method use feedrate expressed in mm/s
>     #define RUNPLAN calculate_delta(destination); \
>                     plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], destination[E_AXIS], feedrate, active_extruder);
>   #else
>     #define SET_FEEDRATE_FOR_MOVE          feedrate = homing_feedrate[X_AXIS];
>     #define SET_FEEDRATE_FOR_EXTRUDER_MOVE feedrate = max_feedrate[E_AXIS] * 60.0;
>     // The following plan method use feedrate expressed in mm/min
>     #define RUNPLAN line_to_destination(feedrate);
>   #endif
>
>   #if ENABLED(DELTA_EXTRA) && ENABLED(Z_MIN_MAGIC)
>
>     bool change_filament_by_tap_tap = false;
>
>     inline void manage_tap_tap() {
>       if ( !startup_auto_calibration
>         && !IS_SD_PRINTING
>         && !change_filament_by_tap_tap
>         #if ENABLED(SUMMON_PRINT_PAUSE)
>         && !print_pause_summoned
>         #endif
>         #if ENABLED(FILAMENT_RUNOUT_SENSOR)
>         && !filament_ran_out
>         #endif
>         && z_magic_hit_count > 1
>       ) {
>         SERIAL_ECHOLNPGM("Tap tap : Heating and changing filament from IDLE state");
>         change_filament_by_tap_tap = true;
>         enqueue_and_echo_commands_P(PSTR("G28\nM104 S180\nG0 F150 X0 Y0 Z100\nM109 S180\nD600\nM106 S255\nM104 S0\nG28"));
>       }
>     }
>
>     inline bool cant_enter_M600_or_D600();
>
>     inline void gcode_D600() {
>       SERIAL_ECHOLNPGM( "Filament expulsion" );
>
>       if (cant_enter_M600_or_D600()) return;
>
>       // Synchronize all moves
>       st_synchronize();
>
>       float previous_dest = destination[E_AXIS];
>       destination[E_AXIS] += FILAMENTCHANGE_FINALRETRACT;
>
>       SET_FEEDRATE_FOR_EXTRUDER_MOVE;
>       RUNPLAN;
>       st_synchronize();
>       destination[E_AXIS] = previous_dest;
>       current_position[E_AXIS] = destination[E_AXIS];
>       sync_plan_position_e();
>
>       change_filament_by_tap_tap = false;
>     }
>   #endif
>
>
>   inline bool cant_enter_M600_or_D600() {
>
>     if (degHotend(active_extruder) < extrude_min_temp) {
>       SERIAL_ERROR_START;
>       SERIAL_ERRORLNPGM(MSG_TOO_COLD_FOR_M600);
>
>       #if ENABLED(FILAMENT_RUNOUT_SENSOR)
>         filament_ran_out = false;
>       #endif
>
>       #if ENABLED(SUMMON_PRINT_PAUSE)
>         print_pause_summoned = false;
>       #endif
>
>       #if ENABLED(DELTA_EXTRA) && ENABLED(Z_MIN_MAGIC)
>         change_filament_by_tap_tap = false;
>       #endif
>
>       return true;
>     }
>
>     return false;
>   }
>
>   #if ENABLED(ONE_LED)
>     // Pre-declaration
>     inline void set_notify_warning();
>   #endif
>
6004a6900,6902
>    *  P[pin]      - Pin to wait for, if not specified use lcd button
>    *              - Pin can be A, B or C respectively for X, Y and Z endstops.
>    *  S[0|1]      - If Pin, state to wait for, if not specified use LOW
6011,6015c6909
<     if (degHotend(active_extruder) < extrude_min_temp) {
<       SERIAL_ERROR_START;
<       SERIAL_ERRORLNPGM(MSG_TOO_COLD_FOR_M600);
<       return;
<     }
---
>     SERIAL_ECHOLNPGM( "Pause for filament change" );
6017,6019c6911,6915
<     float lastpos[NUM_AXIS];
<     #if ENABLED(DELTA)
<       float fr60 = feedrate / 60;
---
>     if (cant_enter_M600_or_D600()) return;
>
>     #if ENABLED(SUMMON_PRINT_PAUSE)
>       // Simulate direct call M600
>       print_pause_summoned = true;
6021a6918,6920
>     float lastpos[NUM_AXIS];
>     float previous_feedrate;
>
6025,6030c6924,6927
<     #if ENABLED(DELTA)
<       #define RUNPLAN calculate_delta(destination); \
<                       plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], destination[E_AXIS], fr60, active_extruder);
<     #else
<       #define RUNPLAN line_to_destination();
<     #endif
---
>     previous_feedrate = feedrate;
>
>     //finish moves
>     // st_synchronize();
6037a6935
>     SET_FEEDRATE_FOR_EXTRUDER_MOVE;
6041,6043c6939,6953
<     if (code_seen('Z')) destination[Z_AXIS] += code_value();
<     #ifdef FILAMENTCHANGE_ZADD
<       else destination[Z_AXIS] += FILAMENTCHANGE_ZADD;
---
>     #if ENABLED(DELTA_EXTRA)
>       float z_destination = destination[Z_AXIS];
>       if (code_seen('Z')) z_destination += code_value();
>       #ifdef FILAMENTCHANGE_ZADD
>         else z_destination += FILAMENTCHANGE_ZADD;
>       #endif
>       NOMORE(z_destination, (Z_MAX_POS-25.0));
>       if (z_destination > destination[Z_AXIS]) {
>         destination[Z_AXIS] = z_destination;
>       }
>     #else
>       if (code_seen('Z')) destination[Z_AXIS] += code_value();
>       #ifdef FILAMENTCHANGE_ZADD
>         else destination[Z_AXIS] += FILAMENTCHANGE_ZADD;
>       #endif
6045a6956
>     SET_FEEDRATE_FOR_MOVE;
6058a6970
>     SET_FEEDRATE_FOR_MOVE;
6065a6978
>     SET_FEEDRATE_FOR_EXTRUDER_MOVE;
6068c6981
<     //finish moves
---
>     // validate planned all moves
6069a6983,7040
>
>     // DAGOMA added
>     // Determine exit/pin state after moving away
>     int pin_number = -1;
>     int target = -1;
>     if (code_seen('P')) {
>       char nextChar = *(seen_pointer + 1);
>       if (nextChar == 'A') {
>         pin_number = X_MIN_PIN;
>       }
>       else if (nextChar == 'B') {
>         pin_number = Y_MAX_PIN;
>       }
>       else if (nextChar == 'C') {
>         pin_number = Z_MIN_PIN;
>       }
>       else {
>         pin_number = code_value();
>       }
>
>       int pin_state = code_seen('S') ? code_value() : -1; // required pin state - default is inverted
>
>       if (pin_state >= -1 && pin_state <= 1) {
>
>         // DAGOMA - byPass sensitive pin
>         /*
>         for (uint8_t i = 0; i < COUNT(sensitive_pins); i++) {
>           if (sensitive_pins[i] == pin_number) {
>             pin_number = -1;
>             break;
>           }
>         }
>         */
>         if (pin_number > -1) {
>           target = LOW;
>
>           //pinMode(pin_number, INPUT);
>
>           switch (pin_state) {
>             case 1:
>               target = HIGH;
>               break;
>
>             case 0:
>               target = LOW;
>               break;
>
>             case -1:
>               target = !digitalRead(pin_number);
>               break;
>           }
>         } // pin_number > -1
>       } // pin_state -1 0 1
>     } // code_seen('P')
>     // END DAGOMA added
>
>
>
6075a7047
>     #if DISABLED(NO_LCD_FOR_FILAMENTCHANGEABLE)
6076a7049
>     #endif
6081,6088c7054,7062
<     while (!lcd_clicked()) {
<       #if DISABLED(AUTO_FILAMENT_CHANGE)
<         millis_t ms = millis();
<         if (ELAPSED(ms, next_tick)) {
<           lcd_quick_feedback();
<           next_tick = ms + 2500UL; // feedback every 2.5s while waiting
<         }
<         idle(true);
---
>
>     #if HAS_FILRUNOUT
>     bool can_exit_pause;
>     do { // Loop while no filament
>       can_exit_pause = true;
>     #endif
>
>       #if DISABLED(NO_LCD_FOR_FILAMENTCHANGEABLE)
>       while ( ! ( lcd_clicked() || (pin_number != -1 && digitalRead(pin_number) == target) ) ) {
6090,6093c7064,7131
<         current_position[E_AXIS] += AUTO_FILAMENT_CHANGE_LENGTH;
<         destination[E_AXIS] = current_position[E_AXIS];
<         line_to_destination(AUTO_FILAMENT_CHANGE_FEEDRATE);
<         st_synchronize();
---
>       while (pin_number != -1 && digitalRead(pin_number) != target) {
>       #endif
>         #if DISABLED(AUTO_FILAMENT_CHANGE)
>           millis_t ms = millis();
>           if (ELAPSED(ms, next_tick)) {
>             #if DISABLED(NO_LCD_FOR_FILAMENTCHANGEABLE)
>             lcd_quick_feedback();
>             #endif
>             next_tick = ms + 2500UL; // feedback every 2.5s while waiting
>
>             // Ensure steppers stay enabled
>             enable_x();
>             enable_y();
>             enable_z();
>
>
>             #if ENABLED( DELTA_EXTRA )
>               // Only checked every 2.5s
>               // Detected if sd is out
>               if ( IS_SD_PRINTING && !card.stillPluggedIn() ) {
>                 // Abort current print
>                 while( true ) {
>                   #if ENABLED(ONE_LED)
>                     one_led_on();
>                     delay(150);
>                     one_led_off();
>                   #endif
>                   delay(150);
>                 }
>                 //abort_sd_printing();
>                 //enqueue_and_echo_commands_P( PSTR("G28") );
>                 return;
>               }
>             #endif
>           }
>
>           #if ENABLED(DELTA_EXTRA) && ENABLED(Z_MIN_MAGIC)
>             // Must be check quicker than 2.5s
>             if ( z_magic_hit_count > 1 ) {
>               gcode_D600();
>             }
>           #endif
>
>           idle(true);
>         #else
>           current_position[E_AXIS] += AUTO_FILAMENT_CHANGE_LENGTH;
>           destination[E_AXIS] = current_position[E_AXIS];
>           line_to_destination(AUTO_FILAMENT_CHANGE_FEEDRATE);
>           st_synchronize();
>         #endif
>       } // while(!lcd_clicked)
>
>       #if ENABLED( NO_LCD_FOR_FILAMENTCHANGEABLE ) && ENABLED( FILAMENT_RUNOUT_SENSOR )
>         // Wait a bit more to see if we want to disable filrunout sensor
>         millis_t now = millis();
>         millis_t long_push = now + 2000UL;
>         delay( 200 );
>         while (pin_number != -1 && digitalRead(pin_number) == target && PENDING(now, long_push)) {
>           enable_x();
>           enable_y();
>           enable_z();
>           idle(true);
>           now = millis();
>         }
>         if ( ELAPSED(now,long_push) ) {
>           filrunout_bypassed = true;
>           SERIAL_ECHOLN( "Filament sensor bypassed" );
>         }
6095c7133,7149
<     } // while(!lcd_clicked)
---
>
>     #if HAS_FILRUNOUT
>         if( !(READ(FILRUNOUT_PIN) ^ FIL_RUNOUT_INVERTING) ) {
>           #if ENABLED(SUMMON_PRINT_PAUSE) && ENABLED( NO_LCD_FOR_FILAMENTCHANGEABLE ) && ENABLED( FILAMENT_RUNOUT_SENSOR )
>           if ( !filrunout_bypassed ) {
>           #endif
>             #if ENABLED(ONE_LED)
>               set_notify_warning();
>             #endif
>             can_exit_pause = false;
>           #if ENABLED(SUMMON_PRINT_PAUSE) && ENABLED( NO_LCD_FOR_FILAMENTCHANGEABLE ) && ENABLED( FILAMENT_RUNOUT_SENSOR )
>           }
>           #endif
>         }
>       } while( !can_exit_pause );
>     #endif
>
6096a7151
>     #if DISABLED(NO_LCD_FOR_FILAMENTCHANGEABLE)
6097a7153
>     #endif
6104c7160
<     //return to normal
---
>     // Return to normal
6112a7169
>     SET_FEEDRATE_FOR_EXTRUDER_MOVE;
6114a7172
>     #if DISABLED(NO_LCD_FOR_FILAMENTCHANGEABLE)
6115a7174
>     #endif
6120,6121c7179,7184
<       plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], destination[E_AXIS], fr60, active_extruder);
<       plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], lastpos[E_AXIS], fr60, active_extruder);
---
>
>       SET_FEEDRATE_FOR_MOVE;
>       plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], destination[E_AXIS], feedrate, active_extruder);
>
>       SET_FEEDRATE_FOR_EXTRUDER_MOVE;
>       plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], lastpos[E_AXIS], feedrate, active_extruder);
6125a7189,7190
>
>       SET_FEEDRATE_FOR_MOVE;
6128a7194
>
6129a7196,7197
>
>       SET_FEEDRATE_FOR_EXTRUDER_MOVE;
6132a7201,7203
>     // Validates all planned moves
>     st_synchronize();
>
6136a7208,7214
>     #if ENABLED(SUMMON_PRINT_PAUSE)
>       print_pause_summoned = false;
>     #endif
>
>     // Restore previous feedrate
>     feedrate = previous_feedrate;
>
6186a7265,7305
> /*****************************************************************************
>  * DAGOMA.FR Specific
>  *****************************************************************************/
> #if ENABLED(WIFI_PRINT)
> inline void gcode_D700() {
>   SECOND_SERIAL.print("SSID:");
>   SECOND_SERIAL.println(current_command_args);
> }
>
> inline void gcode_D701() {
>   SECOND_SERIAL.print("PSWD:");
>   SECOND_SERIAL.println(current_command_args);
> }
>
> inline void gcode_D702() {
>   SECOND_SERIAL.println("REDY");
> }
>
> inline void gcode_D710() {
>   SECOND_SERIAL.print("PNAM:");
>   SECOND_SERIAL.println(current_command_args);
> }
>
> inline void gcode_D711() {
>   SECOND_SERIAL.print("APIU:");
>   SECOND_SERIAL.println(current_command_args);
> }
>
> inline void gcode_D712() {
>   SECOND_SERIAL.print("APIK:");
>   SECOND_SERIAL.println(current_command_args);
> }
>
> inline void gcode_D720() {
>   SERIAL_ECHO_START;
>   SERIAL_ECHOPGM("D:");
>   SERIAL_ECHOLN(current_command_args);
> }
>
> #endif
>
6428a7548,7923
> #if ENABLED( DELTA_EXTRA )
>
> inline void abort_sd_printing() {
>   commands_in_queue = 0;
>   quickStop();
>   card.sdprinting = false;
>   card.closefile();
>   autotempShutdown();
>   setTargetHotend(0, 0);
>   cancel_heatup = true;
> }
>
> inline void gcode_D410() {
>   abort_sd_printing();
> }
>
> inline void gcode_D888() {
>   SERIAL_ECHOLN( "Bizarre procedure" );
>   float z_bizarre = 0.5;
>   if (code_seen('Z')) {
>     z_bizarre = code_value();
>   }
>   float f_bizarre = 3000;
>   if (code_seen('F')) {
>     f_bizarre = code_value();
>   }
>
>   float x_bizarre = 70;
>   if (code_seen('X')) {
>     x_bizarre = code_value();
>   }
>
>   int N = 100;
>   if (code_seen('N')) {
>     N = code_value();
>   }
>
>   for(int i=0; i<N; i++) {
>     feedrate = f_bizarre;
>     destination[X_AXIS] = x_bizarre;
>     destination[Y_AXIS] = 0;
>     destination[Z_AXIS] = z_bizarre;
>     prepare_move();
>     st_synchronize();
>
>     destination[X_AXIS] = x_bizarre + 10.0;
>
>     prepare_move();
>     st_synchronize();
>   }
> }
>
> inline void gcode_D999() {
>   SERIAL_ECHOLN( "Reseting board" );
>   while( true ) {
>     delay(1000);
>   }
> }
>
> inline void gcode_D851() {
>
>   startup_auto_calibration = true;
>
>   SERIAL_ECHOLNPGM( "Starting full Delta calibration" );
>
>   postcompute_tri_ready = false; // Disable tri-delta correction
>
>   gcode_M502(); // Restore factory settings
>
>   if (code_seen('L')) {
>     SERIAL_ECHOPGM( "Overriding L with: " );
>     delta_diagonal_rod = code_value();
>     SERIAL_ECHOLN( delta_diagonal_rod );
>   }
>
>   gcode_M665(); // Re-Calc Delta settings
>   gcode_M500(); // Save settings
>
>   gcode_G28();
>
>
>   feedrate = homing_feedrate[ Z_AXIS ];
>   //feedrate = max_feedrate[ Z_AXIS ] * 60;
>
>   float tower1_altitude, tower2_altitude, tower3_altitude, center_altitude;
>
>   // TOWER 1
>   destination[X_AXIS] = delta_tower1_x;
>   destination[Y_AXIS] = delta_tower1_y;
>   destination[Z_AXIS] = 10.0f;
>   prepare_move();
>   st_synchronize();
>   tower1_altitude = get_probed_Z_avg();
>
>   // TOWER 2
>   destination[X_AXIS] = delta_tower2_x;
>   destination[Y_AXIS] = delta_tower2_y;
>   destination[Z_AXIS] = 10.0f;
>   prepare_move();
>   st_synchronize();
>   tower2_altitude = get_probed_Z_avg();
>
>   // TOWER 3
>   destination[X_AXIS] = delta_tower3_x;
>   destination[Y_AXIS] = delta_tower3_y;
>   destination[Z_AXIS] = 10.0f;
>   prepare_move();
>   st_synchronize();
>   tower3_altitude = get_probed_Z_avg();
>
>   // Use last result as endstops adujst
>   endstop_adj[0] = tower1_altitude /*+ zprobe_zoffset*/;
>   endstop_adj[1] = tower2_altitude /*+ zprobe_zoffset*/;
>   endstop_adj[2] = tower3_altitude /*+ zprobe_zoffset*/;
>
>   // Store endstop adjust
>   gcode_M500();
>
>   // JUST FOR REPORTING BACK
>   // Take in account now
>   gcode_G28();
>
>   feedrate = homing_feedrate[ Z_AXIS ];
>
>   // TOWER 1
>   destination[X_AXIS] = delta_tower1_x;
>   destination[Y_AXIS] = delta_tower1_y;
>   destination[Z_AXIS] = 10.0f;
>   prepare_move();
>   st_synchronize();
>   tower1_altitude = get_probed_Z_avg();
>
>   // TOWER 2
>   destination[X_AXIS] = delta_tower2_x;
>   destination[Y_AXIS] = delta_tower2_y;
>   destination[Z_AXIS] = 10.0f;
>   prepare_move();
>   st_synchronize();
>   tower2_altitude = get_probed_Z_avg();
>
>   // TOWER 3
>   destination[X_AXIS] = delta_tower3_x;
>   destination[Y_AXIS] = delta_tower3_y;
>   destination[Z_AXIS] = 10.0f;
>   prepare_move();
>   st_synchronize();
>   tower3_altitude = get_probed_Z_avg();
>
>
>   // CENTER
>   destination[X_AXIS] = 0.0f;
>   destination[Y_AXIS] = 0.0f;
>   destination[Z_AXIS] = 10.0f;
>   prepare_move();
>   st_synchronize();
>   center_altitude = get_probed_Z_avg();
>
>   SERIAL_ECHOLNPGM( "R probed points:" );
>   SERIAL_ECHOPGM  ( "  T1: " );
>   SERIAL_ECHOLN   ( tower1_altitude );
>   SERIAL_ECHOPGM  ( "  T2: " );
>   SERIAL_ECHOLN   ( tower2_altitude );
>   SERIAL_ECHOPGM  ( "  T3: " );
>   SERIAL_ECHOLN   ( tower3_altitude );
>   SERIAL_ECHOPGM  ( "   C: " );
>   SERIAL_ECHOLN   ( center_altitude );
>
>   float mean_ref_plan_altitude = ( tower1_altitude + tower2_altitude + tower3_altitude ) / 3.0;
>   float diff_center_altitude = center_altitude - mean_ref_plan_altitude;
>
>   SERIAL_ECHOPGM( "Initial mean based difference: " );
>   SERIAL_ECHOLN ( diff_center_altitude );
>
>   SERIAL_ECHOPGM( "Initial delta radius: " );
>   SERIAL_ECHOLN ( delta_radius );
>
>   do {
>     delta_radius -= 2.0 * diff_center_altitude;
>
>     SERIAL_ECHOPGM( "Testing delta radius: " );
>     SERIAL_ECHOLN ( delta_radius );
>
>     gcode_M665();
>
>     destination[X_AXIS] = delta_tower1_x;
>     destination[Y_AXIS] = delta_tower1_y;
>     destination[Z_AXIS] = 10.0f;
>     prepare_move();
>     st_synchronize();
>     tower1_altitude = get_probed_Z_avg();
>
>     // TOWER 2
>     destination[X_AXIS] = delta_tower2_x;
>     destination[Y_AXIS] = delta_tower2_y;
>     destination[Z_AXIS] = 10.0f;
>     prepare_move();
>     st_synchronize();
>     tower2_altitude = get_probed_Z_avg();
>
>     // TOWER 3
>     destination[X_AXIS] = delta_tower3_x;
>     destination[Y_AXIS] = delta_tower3_y;
>     destination[Z_AXIS] = 10.0f;
>     prepare_move();
>     st_synchronize();
>     tower3_altitude = get_probed_Z_avg();
>
>     // CENTER
>     destination[X_AXIS] = 0.0f;
>     destination[Y_AXIS] = 0.0f;
>     destination[Z_AXIS] = 10.0f;
>     prepare_move();
>     st_synchronize();
>     center_altitude = get_probed_Z_avg();
>
>     SERIAL_ECHOLNPGM( "R probed points:" );
>     SERIAL_ECHOPGM  ( "  T1: " );
>     SERIAL_ECHOLN   ( tower1_altitude );
>     SERIAL_ECHOPGM  ( "  T2: " );
>     SERIAL_ECHOLN   ( tower2_altitude );
>     SERIAL_ECHOPGM  ( "  T3: " );
>     SERIAL_ECHOLN   ( tower3_altitude );
>     SERIAL_ECHOPGM  ( "   C: " );
>     SERIAL_ECHOLN   ( center_altitude );
>
>     mean_ref_plan_altitude = ( tower1_altitude + tower2_altitude + tower3_altitude ) / 3.0;
>     diff_center_altitude = center_altitude - mean_ref_plan_altitude;
>
>     SERIAL_ECHOPGM( "NEW Mean based difference: " );
>     SERIAL_ECHOLN ( diff_center_altitude );
>     SERIAL_ECHOPGM( "With delta radius: " );
>     SERIAL_ECHOLN ( delta_radius );
>   } while( abs( diff_center_altitude ) > 0.05 );
>
>
>   SERIAL_ECHOPGM( "Storing delta radius: " );
>   SERIAL_ECHOLN ( delta_radius );
>
>   // Store delta_radius
>   gcode_M500();
>
>   // Take in account now
>   gcode_G28();
>   // Now, we need to adjust endstops offset with the corrected radius
>
>   // TOWER 1
>   destination[X_AXIS] = delta_tower1_x;
>   destination[Y_AXIS] = delta_tower1_y;
>   destination[Z_AXIS] = 10.0f;
>   prepare_move();
>   st_synchronize();
>   tower1_altitude = get_probed_Z_avg();
>
>   // TOWER 2
>   destination[X_AXIS] = delta_tower2_x;
>   destination[Y_AXIS] = delta_tower2_y;
>   destination[Z_AXIS] = 10.0f;
>   prepare_move();
>   st_synchronize();
>   tower2_altitude = get_probed_Z_avg();
>
>   // TOWER 3
>   destination[X_AXIS] = delta_tower3_x;
>   destination[Y_AXIS] = delta_tower3_y;
>   destination[Z_AXIS] = 10.0f;
>   prepare_move();
>   st_synchronize();
>   tower3_altitude = get_probed_Z_avg();
>
>   // CENTER
>   destination[X_AXIS] = 0.0f;
>   destination[Y_AXIS] = 0.0f;
>   destination[Z_AXIS] = 10.0f;
>   prepare_move();
>   st_synchronize();
>   center_altitude = get_probed_Z_avg();
>
>   SERIAL_ECHOLNPGM( "R probed points:" );
>   SERIAL_ECHOPGM  ( "  T1: " );
>   SERIAL_ECHOLN   ( tower1_altitude );
>   SERIAL_ECHOPGM  ( "  T2: " );
>   SERIAL_ECHOLN   ( tower2_altitude );
>   SERIAL_ECHOPGM  ( "  T3: " );
>   SERIAL_ECHOLN   ( tower3_altitude );
>   SERIAL_ECHOPGM  ( "   C: " );
>   SERIAL_ECHOLN   ( center_altitude );
>
>   mean_ref_plan_altitude = ( tower1_altitude + tower2_altitude + tower3_altitude ) / 3.0;
>   diff_center_altitude = center_altitude - mean_ref_plan_altitude;
>
>   SERIAL_ECHOPGM( "Mean based difference: " );
>   SERIAL_ECHOLN( diff_center_altitude );
>
>   SERIAL_ECHOPGM( "With delta radius: " );
>   SERIAL_ECHOLN ( delta_radius );
>
>   // Use last result as endstops adujst
>   endstop_adj[0] += tower1_altitude /*+ zprobe_zoffset*/;
>   endstop_adj[1] += tower2_altitude /*+ zprobe_zoffset*/;
>   endstop_adj[2] += tower3_altitude /*+ zprobe_zoffset*/;
>
>   // Store endstop adjust
>   gcode_M500();
>
>   #if ENABLED(DEBUG_LEVELING_FEATURE)
>     if (DEBUGGING(LEVELING)) {
>
>       // JUST FOR REPORTING BACK
>       // Take in account now
>       gcode_G28();
>
>       // TOWER 1
>       destination[X_AXIS] = delta_tower1_x;
>       destination[Y_AXIS] = delta_tower1_y;
>       destination[Z_AXIS] = 10.0f;
>       prepare_move();
>       st_synchronize();
>       tower1_altitude = get_probed_Z_avg();
>
>       // TOWER 2
>       destination[X_AXIS] = delta_tower2_x;
>       destination[Y_AXIS] = delta_tower2_y;
>       destination[Z_AXIS] = 10.0f;
>       prepare_move();
>       st_synchronize();
>       tower2_altitude = get_probed_Z_avg();
>
>       // TOWER 3
>       destination[X_AXIS] = delta_tower3_x;
>       destination[Y_AXIS] = delta_tower3_y;
>       destination[Z_AXIS] = 10.0f;
>       prepare_move();
>       st_synchronize();
>       tower3_altitude = get_probed_Z_avg();
>
>       // CENTER
>       destination[X_AXIS] = 0.0f;
>       destination[Y_AXIS] = 0.0f;
>       destination[Z_AXIS] = 10.0f;
>       prepare_move();
>       st_synchronize();
>       center_altitude = get_probed_Z_avg();
>
>        SERIAL_ECHOLNPGM( "R probed points:" );
>       SERIAL_ECHOPGM  ( "  T1: " );
>       SERIAL_ECHOLN   ( tower1_altitude );
>       SERIAL_ECHOPGM  ( "  T2: " );
>       SERIAL_ECHOLN   ( tower2_altitude );
>       SERIAL_ECHOPGM  ( "  T3: " );
>       SERIAL_ECHOLN   ( tower3_altitude );
>       SERIAL_ECHOPGM  ( "   C: " );
>       SERIAL_ECHOLN   ( center_altitude );
>
>       mean_ref_plan_altitude = ( tower1_altitude + tower2_altitude + tower3_altitude ) / 3.0;
>       diff_center_altitude = center_altitude - mean_ref_plan_altitude;
>
>       SERIAL_ECHOPGM( "Mean based difference: " );
>       SERIAL_ECHOLN( diff_center_altitude );
>
>       SERIAL_ECHOPGM( "With delta radius: " );
>       SERIAL_ECHOLN ( delta_radius );
>     }
>   #endif
>
>   gcode_G28();
>
>   startup_auto_calibration = false;
> }
>
> #if ENABLED(Z_MIN_MAGIC)
> // Pre-declaration
> inline void gcode_D600();
> #endif
>
> #endif // DELTA_EXTRA End
>
7046a8542,8588
>     case 'D': switch (codenum) {
>       // DAGOMA.FR Specific
>       #if ENABLED(WIFI_PRINT)
>         case 700:
>           gcode_D700(); // SSID
>           break;
>         case 701:
>           gcode_D701(); // PSWD
>           break;
>         case 702:
>           gcode_D702(); // REDY? get ip
>           break;
>         case 710:
>           gcode_D710(); // Tech name
>           break;
>         case 711:
>           gcode_D711(); // API Url
>           break;
>         case 712:
>           gcode_D712(); // API Key
>           break;
>         case 720:
>           gcode_D720(); // ECHO
>           break;
>         #endif
>       #if ENABLED( DELTA_EXTRA )
>         case 410:
>           gcode_D410();
>           break;
>         #if ENABLED(Z_MIN_MAGIC)
>           case 600:
>             gcode_D600();
>             break;
>         #endif
>         case 851:
>           gcode_D851();
>           break;
>         case 888:
>           gcode_D888();
>           break;
>         case 999:
>           gcode_D999();
>           break;
>       #endif
>       // DAGOMA.FR End
>       }
>     break;
7125a8668,8750
>
>     #if ENABLED( DELTA_EXTRA )
>       int i=0;
>       // Outer
>       probe_plan[i][0] = delta_tower1_x;
>       probe_plan[i][1] = delta_tower1_y;
>       i++;
>
>       probe_plan[i][0] = -COS_60 * radius;
>       probe_plan[i][1] = -SIN_60 * radius;
>       i++;
>
>       probe_plan[i][0] = 0.0;
>       probe_plan[i][1] = -1.0 * radius;
>       i++;
>
>       probe_plan[i][0] = COS_60 * radius;
>       probe_plan[i][1] = -SIN_60 * radius;
>       i++;
>
>       probe_plan[i][0] = delta_tower2_x;
>       probe_plan[i][1] = delta_tower2_y;
>       i++;
>
>       probe_plan[i][0] = radius;
>       probe_plan[i][1] = 0.0;
>       i++;
>
>       probe_plan[i][0] = SIN_60 * radius;
>       probe_plan[i][1] = COS_60 * radius;
>       i++;
>
>       probe_plan[i][0] = COS_60 * radius;
>       probe_plan[i][1] = SIN_60 * radius;
>       i++;
>
>       probe_plan[i][0] = delta_tower3_x;
>       probe_plan[i][1] = delta_tower3_y;
>       i++;
>
>       probe_plan[i][0] = -COS_60 * radius;
>       probe_plan[i][1] = SIN_60 * radius;
>       i++;
>
>       probe_plan[i][0] = -SIN_60 * radius;
>       probe_plan[i][1] = COS_60 * radius;
>       i++;
>
>       probe_plan[i][0] = -radius;
>       probe_plan[i][1] = 0.0;
>       i++;
>
>       // Inner
>       probe_plan[i][0] = -SIN_60 * radius / 2.0;
>       probe_plan[i][1] = -COS_60 * radius / 2.0;
>       i++;
>
>       probe_plan[i][0] = 0.0;
>       probe_plan[i][1] = -radius / 2.0;
>       i++;
>
>       probe_plan[i][0] = SIN_60 * radius / 2.0;
>       probe_plan[i][1] = -COS_60 * radius / 2.0;
>       i++;
>
>       probe_plan[i][0] = SIN_60 * radius / 2.0;
>       probe_plan[i][1] = COS_60 * radius / 2.0;
>       i++;
>
>       probe_plan[i][0] = 0.0;
>       probe_plan[i][1] = radius / 2.0;
>       i++;
>
>       probe_plan[i][0] = -SIN_60 * radius / 2.0;
>       probe_plan[i][1] = COS_60 * radius / 2.0;
>       i++;
>
>       // Center
>       probe_plan[i][0] = 0.0;
>       probe_plan[i][1] = 0.0;
>       i++;
>
>     #endif
7154a8780,8788
>     inline float triangle_get_point_offset( const float x, const float y, const short t ) {
>       // z = - (d + b.y + a.x) / c ;
>       return - (
>         probed_tri_postcompute_d[t] +
>         probed_tri_postcompute_b[t] * y +
>         probed_tri_postcompute_a[t] * x
>       ) / probed_tri_postcompute_c[t];
>     }
>
7157c8791,8792
<       if (delta_grid_spacing[0] == 0 || delta_grid_spacing[1] == 0) return; // G29 not done!
---
>       #if DISABLED( DELTA_EXTRA )
>         if (delta_grid_spacing[0] == 0 || delta_grid_spacing[1] == 0) return; // G29 not done!
7159,7175c8794,8810
<       int half = (AUTO_BED_LEVELING_GRID_POINTS - 1) / 2;
<       float h1 = 0.001 - half, h2 = half - 0.001,
<             grid_x = max(h1, min(h2, cartesian[X_AXIS] / delta_grid_spacing[0])),
<             grid_y = max(h1, min(h2, cartesian[Y_AXIS] / delta_grid_spacing[1]));
<       int floor_x = floor(grid_x), floor_y = floor(grid_y);
<       float ratio_x = grid_x - floor_x, ratio_y = grid_y - floor_y,
<             z1 = bed_level[floor_x + half][floor_y + half],
<             z2 = bed_level[floor_x + half][floor_y + half + 1],
<             z3 = bed_level[floor_x + half + 1][floor_y + half],
<             z4 = bed_level[floor_x + half + 1][floor_y + half + 1],
<             left = (1 - ratio_y) * z1 + ratio_y * z2,
<             right = (1 - ratio_y) * z3 + ratio_y * z4,
<             offset = (1 - ratio_x) * left + ratio_x * right;
<
<       delta[X_AXIS] += offset;
<       delta[Y_AXIS] += offset;
<       delta[Z_AXIS] += offset;
---
>         int half = (AUTO_BED_LEVELING_GRID_POINTS - 1) / 2;
>         float h1 = 0.001 - half, h2 = half - 0.001,
>               grid_x = max(h1, min(h2, cartesian[X_AXIS] / delta_grid_spacing[0])),
>               grid_y = max(h1, min(h2, cartesian[Y_AXIS] / delta_grid_spacing[1]));
>         int floor_x = floor(grid_x), floor_y = floor(grid_y);
>         float ratio_x = grid_x - floor_x, ratio_y = grid_y - floor_y,
>               z1 = bed_level[floor_x + half][floor_y + half],
>               z2 = bed_level[floor_x + half][floor_y + half + 1],
>               z3 = bed_level[floor_x + half + 1][floor_y + half],
>               z4 = bed_level[floor_x + half + 1][floor_y + half + 1],
>               left = (1 - ratio_y) * z1 + ratio_y * z2,
>               right = (1 - ratio_y) * z3 + ratio_y * z4,
>               offset = (1 - ratio_x) * left + ratio_x * right;
>
>         delta[X_AXIS] += offset;
>         delta[Y_AXIS] += offset;
>         delta[Z_AXIS] += offset;
7177,7191c8812,8855
<       /**
<       SERIAL_ECHOPGM("grid_x="); SERIAL_ECHO(grid_x);
<       SERIAL_ECHOPGM(" grid_y="); SERIAL_ECHO(grid_y);
<       SERIAL_ECHOPGM(" floor_x="); SERIAL_ECHO(floor_x);
<       SERIAL_ECHOPGM(" floor_y="); SERIAL_ECHO(floor_y);
<       SERIAL_ECHOPGM(" ratio_x="); SERIAL_ECHO(ratio_x);
<       SERIAL_ECHOPGM(" ratio_y="); SERIAL_ECHO(ratio_y);
<       SERIAL_ECHOPGM(" z1="); SERIAL_ECHO(z1);
<       SERIAL_ECHOPGM(" z2="); SERIAL_ECHO(z2);
<       SERIAL_ECHOPGM(" z3="); SERIAL_ECHO(z3);
<       SERIAL_ECHOPGM(" z4="); SERIAL_ECHO(z4);
<       SERIAL_ECHOPGM(" left="); SERIAL_ECHO(left);
<       SERIAL_ECHOPGM(" right="); SERIAL_ECHO(right);
<       SERIAL_ECHOPGM(" offset="); SERIAL_ECHOLN(offset);
<       */
---
>         /**
>         SERIAL_ECHOPGM("grid_x="); SERIAL_ECHO(grid_x);
>         SERIAL_ECHOPGM(" grid_y="); SERIAL_ECHO(grid_y);
>         SERIAL_ECHOPGM(" floor_x="); SERIAL_ECHO(floor_x);
>         SERIAL_ECHOPGM(" floor_y="); SERIAL_ECHO(floor_y);
>         SERIAL_ECHOPGM(" ratio_x="); SERIAL_ECHO(ratio_x);
>         SERIAL_ECHOPGM(" ratio_y="); SERIAL_ECHO(ratio_y);
>         SERIAL_ECHOPGM(" z1="); SERIAL_ECHO(z1);
>         SERIAL_ECHOPGM(" z2="); SERIAL_ECHO(z2);
>         SERIAL_ECHOPGM(" z3="); SERIAL_ECHO(z3);
>         SERIAL_ECHOPGM(" z4="); SERIAL_ECHO(z4);
>         SERIAL_ECHOPGM(" left="); SERIAL_ECHO(left);
>         SERIAL_ECHOPGM(" right="); SERIAL_ECHO(right);
>         SERIAL_ECHOPGM(" offset="); SERIAL_ECHOLN(offset);
>         */
>       #else // if DELTA_EXTRA
>         if ( ! postcompute_tri_ready ) return;
>
>         if ( cartesian[Z_AXIS] > z_smooth_tri_leveling_height ) return;
>
>         // Find the index tri for z correction
>         short idx = triangle_index( cartesian[X_AXIS], cartesian[Y_AXIS] );
>
>         // Get offset from tri equations
>         float offset = triangle_get_point_offset( cartesian[X_AXIS], cartesian[Y_AXIS], idx );
>
>         // Adjust final-offset againt Z altitude
>         // to reduce it after 0.6mm
>         offset *= ( z_smooth_tri_leveling_height - cartesian[Z_AXIS] ) / z_smooth_tri_leveling_height;
>
>         delta[X_AXIS] += offset;
>         delta[Y_AXIS] += offset;
>         delta[Z_AXIS] += offset;
>
>         delta[X_AXIS] += zprobe_zoffset;
>         delta[Y_AXIS] += zprobe_zoffset;
>         delta[Z_AXIS] += zprobe_zoffset;
>
>         // Bed support smoothness
>         delta[X_AXIS] += 0.05;
>         delta[Y_AXIS] += 0.05;
>         delta[Z_AXIS] += 0.05;
>
>       #endif // End DELTA_EXTRA
7735a9400,9568
> #if ENABLED(ONE_BUTTON)
>
>   millis_t next_one_button_check = 0;
>   bool asked_to_print = false;
>   bool asked_to_pause = false;
>   millis_t has_to_print_timeout = 0;
>
> #endif
>
> #if ENABLED(ONE_LED)
>
>   int state_blink = 0;
>   millis_t next_one_led_tick = 0;
>   bool notify_warning = false;
>   millis_t notify_warning_timeout = 0;
>
>   inline void set_notify_warning() {
>     notify_warning = true;
>     notify_warning_timeout = millis() + 2000UL;
>   }
>
>   inline void manage_one_led() {
>     millis_t now = millis();
>     if ( PENDING( now, next_one_led_tick ) ) return;
>
>     state_blink = ( state_blink + 1 ) % 10;
>     next_one_led_tick = now + 150UL;
>
>     if ( startup_auto_calibration ) {
>       switch( state_blink ) {
>         case 0:
>           one_led_on();
>           break;
>         default:
>           one_led_off();
>       }
>     }
>     #if ENABLED( ONE_BUTTON )
>     else if ( asked_to_print ) {
>       one_led_on();
>     }
>     #endif
>     else if ( notify_warning ) {
>       state_blink % 2 ? one_led_on() : one_led_off();
>       if ( ELAPSED(now, notify_warning_timeout) ) {
>         notify_warning = false;
>       }
>     }
>     else if (
>       false
>       #if ENABLED(SUMMON_PRINT_PAUSE)
>       || print_pause_summoned
>       #endif
>       #if ENABLED(FILAMENT_RUNOUT_SENSOR)
>       || filament_ran_out
>       #endif
>     ) {
>       switch( state_blink ) {
>         case 0:
>         case 2:
>           one_led_on();
>           break;
>         default:
>           one_led_off();
>       }
>     }
>     else {
>       if ( IS_SD_PRINTING ) {
>         one_led_on();
>       }
>       else {
>         one_led_off();
>       }
>     }
>   }
> #endif
>
> #if ENABLED(SUMMON_PRINT_PAUSE)
>
>   inline void manage_pause_summoner() {
>     // PAUSE PUSHED
>     if (!print_pause_summoned
>       #if ENABLED( FILAMENT_RUNOUT_SENSOR )
>       && !filament_ran_out
>       #endif
>       #if ENABLED( ONE_BUTTON )
>       && !asked_to_print
>       #endif
>       ) {
>       if (
>         IS_SD_PRINTING
>         && ( READ(SUMMON_PRINT_PAUSE_PIN) ^ SUMMON_PRINT_PAUSE_INVERTING )
>         && axis_homed[X_AXIS]
>         && axis_homed[Y_AXIS]
>         && axis_homed[Z_AXIS]
>         ) {
>           SERIAL_ECHOLNPGM("Pause : Summoned by user bouton press");
>           print_pause_summoned = true;
>           enqueue_and_echo_commands_P(PSTR(SUMMON_PRINT_PAUSE_SCRIPT));
>       }
>     }
>   }
>
> #endif // SUMMON_PRINT_PAUSE
>
> #if ENABLED(ONE_BUTTON)
>
>   inline void manage_one_button() {
>     // De-Bounce bouton press
>     millis_t now = millis();
>     if (PENDING(now, next_one_button_check)) return;
>     next_one_button_check = now + 100UL;
>
>     if ( IS_SD_PRINTING
>       && asked_to_print
>       && !( READ(ONE_BUTTON_PIN) ^ ONE_BUTTON_INVERTING )
>     ) {
>       asked_to_print = false;
>     }
>
>     if ( !IS_SD_PRINTING
>       && asked_to_print
>       && !( READ(ONE_BUTTON_PIN) ^ ONE_BUTTON_INVERTING )
>       && ELAPSED(now, has_to_print_timeout)
>     ) {
>       asked_to_print = false;
>       #if ENABLED(ONE_LED)
>         set_notify_warning();
>       #endif
>     }
>
>     if ( !startup_auto_calibration
>       && !IS_SD_PRINTING
>       && !asked_to_print
>       && ( READ(ONE_BUTTON_PIN) ^ ONE_BUTTON_INVERTING )
>     ) {
>       // Warns user if no filament at start/resume.
>       #if HAS_FILRUNOUT
>         if( !(READ(FILRUNOUT_PIN) ^ FIL_RUNOUT_INVERTING) ) {
>           set_notify_warning();
>           return;
>         }
>       #endif
>
>       #if ENABLED( FILAMENT_RUNOUT_SENSOR )
>         filrunout_bypassed = false;
>       #endif
>       asked_to_print = true;
>       has_to_print_timeout = now + 2500UL;
>
>       #if ENABLED(ONE_LED)
>         one_led_on();
>       #endif
>
>       card.autostart_index = 0;
>       card.cardOK = false;
>       card.checkautostart( true );
>
>       #if ENABLED(ONE_LED)
>         if ( !card.cardOK ) set_notify_warning();
>       #endif
>     }
>   }
> #endif
>
> #if ENABLED( Z_MIN_MAGIC )
>   millis_t last_debug_z_magic_timing = 0UL;
> #endif
>
7743a9577,9584
>
> /*
>   if (z_magic_derivative_bias < -5.0) {
>     SERIAL_ECHO("z_magic_d: ");
>     SERIAL_ECHOLN(z_magic_derivative_bias);
>   }
> */
>
7744a9586,9597
>   #if ENABLED(SUMMON_PRINT_PAUSE)
>   manage_pause_summoner();
>   #endif
>   #if ENABLED(ONE_BUTTON)
>   manage_one_button();
>   #endif
>   #if ENABLED(ONE_LED)
>   manage_one_led();
>   #endif
>   #if ENABLED(DELTA_EXTRA) && ENABLED(Z_MIN_MAGIC)
>   manage_tap_tap();
>   #endif
7751c9604,9645
<   lcd_update();
---
>   #if ENABLED(U8GLIB_SSD1306) && ENABLED(INTELLIGENT_LCD_REFRESH_RATE)
>     if (IS_SD_PRINTING && axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS]) {
>
>       if ( last_intelligent_F_lcd_update != feedrate ) {
>         last_intelligent_F_authorized_lcd_update = feedrate > last_intelligent_F_lcd_update;
>         last_intelligent_F_lcd_update = feedrate;
>       }
>
>       if ( last_intelligent_z_lcd_update != current_position[Z_AXIS] || last_intelligent_F_authorized_lcd_update ) {
>         last_intelligent_z_lcd_update = current_position[Z_AXIS];
>         lcd_update();
>       }
>
>     }
>     else {
>       lcd_update();
>     }
>   #else
>     lcd_update();
>   #endif
>
>   #if ENABLED( WIFI_PRINT )
>     manage_second_serial_status();
>   #endif
>
>   #if ENABLED( Z_MIN_MAGIC )
>     if (DEBUGGING(LEVELING)) {
>       millis_t now = millis();
>       if (ELAPSED(now, last_debug_z_magic_timing)) {
>         SERIAL_ECHOPGM("Z Magic (tstp / pressure / bias / tap): ");
>         SERIAL_ECHO( millis() );
>         SERIAL_ECHOPGM(" / ");
>         SERIAL_ECHO( z_magic_value );
>         SERIAL_ECHOPGM(" / ");
>         SERIAL_ECHO( z_magic_derivative_bias );
>         SERIAL_ECHOPGM(" / ");
>         SERIAL_ECHO( z_magic_hit_count );
>         SERIAL_ECHOLNPGM("");
>         last_debug_z_magic_timing = now + 250UL; // 2times a second
>       }
>     }
>   #endif
7766a9661
>   millis_t ms = millis();
7769,7770c9664,9684
<     if (IS_SD_PRINTING && !(READ(FILRUNOUT_PIN) ^ FIL_RUNOUT_INVERTING))
<       handle_filament_runout();
---
>     if (
>       IS_SD_PRINTING
>       #if ENABLED( SUMMON_PRINT_PAUSE )
>       && !filrunout_bypassed
>       && !print_pause_summoned
>       #endif
>       && !(READ(FILRUNOUT_PIN) ^ FIL_RUNOUT_INVERTING)
>       && axis_homed[X_AXIS]
>       && axis_homed[Y_AXIS]
>       && axis_homed[Z_AXIS]
>       ) {
>       if(ELAPSED(ms, frs_debounce_time)) {
>         if (frs_debounce_time == 0UL) {
>           frs_debounce_time = ms + FRS_DEBOUNCE_DELAY;
>         } else {
>           handle_filament_runout();
>         }
>       }
>     } else {
>       frs_debounce_time = 0UL;
>     }
7775,7776d9688
<   millis_t ms = millis();
<
7839a9752,9783
>   #if ENABLED(IS_MONO_FAN) || ENABLED(PRINTER_HEAD_EASY)
>     if ( ELAPSED(ms, next_fan_auto_regulation_check) ) {
>       float max_temp = 0.0;
>       for (int8_t cur_extruder = 0; cur_extruder < EXTRUDERS; ++cur_extruder)
>         max_temp = max(max_temp, degHotend(cur_extruder));
>
>       #if ENABLED(IS_MONO_FAN)
>         short fs = 0;
>         if ( max_temp < MONO_FAN_MIN_TEMP ) {
>           fs = 0;
>         }
>         else {
>           fs = fanSpeeds[0];
>           NOLESS(fs, MONO_FAN_MIN_PWM);
>         }
>
>         fanSpeeds[0] = fs;
>       #endif
>
>       #if ENABLED(PRINTER_HEAD_EASY)
>         if ( max_temp < PRINTER_HEAD_EASY_CONSTANT_FAN_MIN_TEMP ) {
>           analogWrite(PRINTER_HEAD_EASY_CONSTANT_FAN_PIN, 0);
>         }
>         else {
>           analogWrite(PRINTER_HEAD_EASY_CONSTANT_FAN_PIN, 255);
>         }
>       #endif
>
>       next_fan_auto_regulation_check = ms + 2500UL;
>     }
>   #endif
>
7927a9872,9904
>   #if ENABLED( DELTA_EXTRA )
>     #if ENABLED( SDSUPPORT )
>       // Dump error msg onto sd card
>       abort_sd_printing();
>       card.initsd();
>       if ( card.cardOK ) {
>         char logfilename[30];
>         sprintf_P(logfilename, PSTR("errmsg.d"));
>         // First, delete previous if exists
>         card.removeFile( logfilename );
>         // Then, create it
>         card.openLogFile( logfilename );
>         if ( card.saving ) {
>           if ( card.writePGM( lcd_msg ) ) {
>             SERIAL_ECHOLNPGM( "errmsg.d : file written, for more information." );
>           }
>           else {
>             SERIAL_ECHOLNPGM( "errmsg.d : can't write file content" );
>           }
>           card.closefile();
>           card.release();
>         }
>         else {
>           SERIAL_ECHOLNPGM( "errmsg.d : can't create file" );
>         }
>       }
>       else {
>         SERIAL_ECHOLNPGM( "errmsg.d : can't init sd card" );
>       }
>     #endif
>     gcode_G28();
>   #endif
>
7942c9919,9921
<   cli();   // disable interrupts
---
>   #if DISABLED( ONE_LED )
>     cli();   // disable interrupts
>   #endif
7947a9927,9932
>     #if ENABLED( ONE_LED )
>       one_led_on();
>       delay(70);
>       one_led_off();
>       delay(140);
>     #endif
7952d9936
<
7954a9939
>       SERIAL_ECHOLNPGM("Pause : No more filament detected");
diff Marlin/stepper.cpp ../DiscoEasy200/stepper.cpp
482,484c492,513
<         #if ENABLED(Z_MIN_PROBE_ENDSTOP) && DISABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) && ENABLED(HAS_Z_MIN_PROBE)
<           if (z_probe_is_active) {
<             UPDATE_ENDSTOP(Z, MIN_PROBE);
---
>         // Check if pause is triggered during z probe
>         #if ENABLED(HAS_Z_MIN_PROBE)
>           #if ENABLED(EMERGENCY_STOP)
>             #if ENABLED(DELTA) && ENABLED(ONE_BUTTON) // Delta
>               if ( (READ(ONE_BUTTON_PIN) ^ ONE_BUTTON_INVERTING) ) {
>                 SET_BIT(current_endstop_bits, Z_MIN_PROBE, 1 ); // Emulate endstops hit (here: Z_MIN)
>                 trigger_emergency_stop = true;
>               }
>             #elif ENABLED(SUMMON_PRINT_PAUSE) // E200 Neva-like (with pause button)
>               if ( (READ(SUMMON_PRINT_PAUSE_PIN) ^ SUMMON_PRINT_PAUSE_INVERTING) ) {
>                 SET_BIT(current_endstop_bits, Z_MIN_PROBE, 1 ); // Emulate endstops hit (here: Z_MIN)
>                 trigger_emergency_stop = true;
>               }
>             #endif
>
>             // Assumption: this piece of code is used to stop the move in checking bit in Z_MIN_PROBE flag.
>             if (TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE)) && current_block->steps[_AXIS(Z)] > 0) {
>               _SET_TRIGSTEPS(Z);
>               _ENDSTOP_HIT(Z);
>               step_events_completed = current_block->step_event_count;
>             }
>
486c515,569
<           }
---
>
>             // FIXME: Quick fix to exit earlier
>             //        If emergency stop is triggered
>             // TODO:  See if this code can be avoided with below Z_MIN_MAGIC possible override
>             //        of emergency occurrences
>             if (trigger_emergency_stop) {
>               old_endstop_bits = current_endstop_bits;
>               return;
>             }
>           #endif
>         #endif
>
>         #if ENABLED(Z_MIN_PROBE_ENDSTOP) && DISABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) && ENABLED(HAS_Z_MIN_PROBE)
>           #if ENABLED( Z_MIN_MAGIC )
>               if ( z_probe_is_active /*&& can_measure_z_magic*/ ) {
>                 //int z_sensor_i = analogRead( Z_MIN_PROBE_PIN );
>                 int z_sensor_i = z_magic_value;
>                 float z_sensor_f = float( z_sensor_i );
>                 float derivative_bias = ( z_sensor_f - last_measures_avg ) / 2.0;
>
>                 /*if ( derivative_bias > -2.0 ) {*/
>                 if ( z_magic_derivative_bias > -5.0 ) {
>                   // We do not hit anything
>                   SET_BIT(current_endstop_bits, Z_MIN_PROBE, 0 );
>                 }
>                 else {
>                   // We hit something
>                   SET_BIT(current_endstop_bits, Z_MIN_PROBE, 1 );
>                 }
>
>                 // Update last_measures avg
>                 last_measures[ last_measures_idx ] = z_sensor_f;
>                 last_measures_idx = ( last_measures_idx + 1 ) % LAST_MEASURE_NUMBER;
>
>                 last_measures_avg = last_measures[0];
>                 for( int i=1; i<LAST_MEASURE_NUMBER; i++ ) {
>                   last_measures_avg += last_measures[ i ];
>                 }
>                 last_measures_avg /= float( LAST_MEASURE_NUMBER );
>
>                 if (TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE)) && current_block->steps[_AXIS(Z)] > 0) {
>                   _SET_TRIGSTEPS(Z);
>                   _ENDSTOP_HIT(Z);
>                   step_events_completed = current_block->step_event_count;
>                 }
>
>                 if (TEST_ENDSTOP(Z_MIN_PROBE)) SBI(endstop_hit_bits, Z_MIN_PROBE);
>
>               } // END z_probe_is_active
>           #else
>             if (z_probe_is_active) {
>               UPDATE_ENDSTOP(Z, MIN_PROBE);
>               if (TEST_ENDSTOP(Z_MIN_PROBE)) SBI(endstop_hit_bits, Z_MIN_PROBE);
>             }
>           #endif
diff Marlin/ultralcd.cpp ../DiscoEasy200/ultralcd.cpp
875a893,954
> void lcd_parallel_x(){
>   lcd_return_to_status();
>
>   enqueue_and_echo_commands_P( PSTR("M117 Origine Machine") );  // ; Message sur afficheur
>   enqueue_and_echo_commands_P( PSTR("M84") );  //                  ; Disable motors to encure Z_SAFE_HOMING
>   #if ENABLED(Z_DUAL_ENDSTOPS)
>     enqueue_and_echo_commands_P( PSTR("M666 Z0") );
>   #endif
>   enqueue_and_echo_commands_P( PSTR("G28") );  //             	   ; Home X Y Z
>   enqueue_and_echo_commands_P( PSTR("G90") );  //                	 ; Passage coordonnees absolues
>   wait_all_commands_finished__CALLABLE_FROM_LCD_ONLY();
>
>   //;Parallelisme Axe X
>   enqueue_and_echo_commands_P( PSTR("M117 Parallelisme X") );  //      ; Message sur afficheur
>   #if DISABLED(Z_DUAL_ENDSTOPS)
>     enqueue_and_echo_commands_P( PSTR("G1 Z5 F9000") );  //           ; lift nozzle
>     wait_all_commands_finished__CALLABLE_FROM_LCD_ONLY();
>
>     enqueue_and_echo_commands_P( PSTR("G1 X-24 Y-14 F9000") );  //
>     enqueue_and_echo_commands_P( PSTR("G92 Z20") );  //
>     enqueue_and_echo_commands_P( PSTR("G91") );  //                   ; Passage coordonnees relatives
>     wait_all_commands_finished__CALLABLE_FROM_LCD_ONLY();
>
>     enqueue_and_echo_commands_P( PSTR("G1 Z-15 F200") );  //		     ; Descente en dessous du plateau
>     enqueue_and_echo_commands_P( PSTR("G1 Z15 F9000") );  //
>     enqueue_and_echo_commands_P( PSTR("G28") );  //		            ; Home
>     wait_all_commands_finished__CALLABLE_FROM_LCD_ONLY();
>   #else
>     enqueue_and_echo_commands_P( PSTR("G1 X0 F9000") );
>     enqueue_and_echo_commands_P( PSTR("G30") );
>     wait_all_commands_finished__CALLABLE_FROM_LCD_ONLY();
>
>     float z_left, z_right, z_diff;
>     #if ENABLED(HAS_SERVO_ENDSTOPS)
>       z_left = z_probed_value_before_z_raise;
>     #else
>       z_left = current_position[ Z_AXIS ];
>     #endif
>
>     enqueue_and_echo_commands_P( PSTR("G1 X350 F9000") );
>     enqueue_and_echo_commands_P( PSTR("G30") );
>     wait_all_commands_finished__CALLABLE_FROM_LCD_ONLY();
>
>
>     #if ENABLED(HAS_SERVO_ENDSTOPS)
>       z_right = z_probed_value_before_z_raise;
>     #else
>       z_right = current_position[ Z_AXIS ];
>     #endif
>
>     z_diff = z_right - z_left;
>     z_endstop_adj = z_diff;
>
>     enqueue_and_echo_commands_P( PSTR("G28") );
>     enqueue_and_echo_commands_P( PSTR("M666 Z0") );
>     wait_all_commands_finished__CALLABLE_FROM_LCD_ONLY();
>
>   #endif // Z_DUAL_ENDSTOPS
>
>   enqueue_and_echo_commands_P( PSTR("G90") );  //                   ; Passage coordonnees absolues
> }
>
1081a1161,1164
>   /**
>    * Step 1: MBL entry-point: "Cancel" or "Level Bed"
>    */
>
1089a1173,1181
>  //Prparer
>    // Dplacer un axes
>    // Prchanffage PLA
>    // Rglage Offset
>    // Refroidir
>    // Eteindre alim.
>    // Tout le reste : Rglages avancs
>      // Prchauffage ABS
>
1097a1190
>
1099c1192
<   // Auto Home
---
>   // Move Axis
1101c1194
<   MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
---
>   MENU_ITEM(submenu, MSG_MOVE_AXIS, lcd_move_menu);
1104c1197,1198
<   // Set Home Offsets
---
>   // Preheat PLA
>   // Preheat ABS
1106,1107c1200,1210
<   MENU_ITEM(function, MSG_SET_HOME_OFFSETS, lcd_set_home_offsets);
<   //MENU_ITEM(gcode, MSG_SET_ORIGIN, PSTR("G92 X0 Y0 Z0"));
---
>   #if TEMP_SENSOR_0 != 0
>     #if TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_3 != 0 || TEMP_SENSOR_BED != 0
>       MENU_ITEM(submenu, MSG_PREHEAT_PLA, lcd_preheat_pla_menu);
>     #else
>       MENU_ITEM(function, MSG_PREHEAT_PLA, lcd_preheat_pla0);
>     #endif
>   #endif
>
>   #if ENABLED(PARALLEL_X_FEATURE)
>     MENU_ITEM(function, MSG_PARALLEL_X, lcd_parallel_x);
>   #endif
1113,1117c1216
<     MENU_ITEM(gcode, MSG_LEVEL_BED,
<       axis_homed[X_AXIS] && axis_homed[Y_AXIS] ? PSTR("G29") : PSTR("G28\nG29")
<     );
<   #elif ENABLED(MANUAL_BED_LEVELING)
<     MENU_ITEM(submenu, MSG_LEVEL_BED, lcd_level_bed);
---
>     MENU_ITEM(submenu, MSG_Z_OFFSET, lcd_set_z_offsets);
1119a1219
>
1121c1221
<   // Move Axis
---
>   // Cooldown
1123c1223
<   MENU_ITEM(submenu, MSG_MOVE_AXIS, lcd_move_menu);
---
>   MENU_ITEM(function, MSG_COOLDOWN, lcd_cooldown);
1126c1226
<   // Disable Steppers
---
>   // Switch power on/off
1128c1228,1261
<   MENU_ITEM(gcode, MSG_DISABLE_STEPPERS, PSTR("M84"));
---
>   #if HAS_POWER_SWITCH
>     if (powersupply)
>       MENU_ITEM(gcode, MSG_SWITCH_PS_OFF, PSTR("M81"));
>     else
>       MENU_ITEM(gcode, MSG_SWITCH_PS_ON, PSTR("M80"));
>   #endif
>
>   MENU_ITEM(submenu, MSG_PREPARE_ADVENCED, lcd_prepare_advanced_menu);
>
>   END_MENU();
> }
>
> static void lcd_prepare_advanced_menu() {
>   START_MENU();
>
>   //
>   // ^ Main
>   //
>   MENU_ITEM(back, MSG_MAIN);
>   //
>   // Auto Home
>   //
>   MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
>
>   //
>   // Level Bed
>   //
>   #if ENABLED(AUTO_BED_LEVELING_FEATURE)
>     MENU_ITEM(gcode, MSG_LEVEL_BED,
>       axis_homed[X_AXIS] && axis_homed[Y_AXIS] ? PSTR("G29") : PSTR("G28\nG29")
>     );
>   #elif ENABLED(MANUAL_BED_LEVELING)
>     MENU_ITEM(submenu, MSG_LEVEL_BED, lcd_level_bed);
>   #endif
1136d1268
<       MENU_ITEM(submenu, MSG_PREHEAT_PLA, lcd_preheat_pla_menu);
1139d1270
<       MENU_ITEM(function, MSG_PREHEAT_PLA, lcd_preheat_pla0);
1145c1276
<   // Cooldown
---
>   // Set Home Offsets
1147c1278,1279
<   MENU_ITEM(function, MSG_COOLDOWN, lcd_cooldown);
---
>   MENU_ITEM(function, MSG_SET_HOME_OFFSETS, lcd_set_home_offsets);
>   //MENU_ITEM(gcode, MSG_SET_ORIGIN, PSTR("G92 X0 Y0 Z0"));
1150c1282
<   // Switch power on/off
---
>   // Disable Steppers
1152,1157c1284
<   #if HAS_POWER_SWITCH
<     if (powersupply)
<       MENU_ITEM(gcode, MSG_SWITCH_PS_OFF, PSTR("M81"));
<     else
<       MENU_ITEM(gcode, MSG_SWITCH_PS_ON, PSTR("M80"));
<   #endif
---
>   MENU_ITEM(gcode, MSG_DISABLE_STEPPERS, PSTR("M84"));
1205a1333,1366
>
> static void _lcd_move_callback(const char* name, AxisEnum axis, float min, float max, menuFunc_t callback) {
>   ENCODER_DIRECTION_NORMAL();
>   if (encoderPosition && movesplanned() <= 3) {
>     refresh_cmd_timeout();
>     current_position[axis] += float((int32_t)encoderPosition) * move_menu_scale;
>     if (min_software_endstops) NOLESS(current_position[axis], min);
>     if (max_software_endstops) NOMORE(current_position[axis], max);
>     line_to_current(axis);
>     lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
>   }
>   encoderPosition = 0;
>   if (lcdDrawUpdate) lcd_implementation_drawedit(name, ftostr31(current_position[axis]));
>   if (LCD_CLICKED) (*callback)();
> }
>
> #if ENABLED( AUTO_BED_LEVELING_FEATURE )
>   static void _lcd_move_callback_with_offset(const char* name, AxisEnum axis, float min, float max, menuFunc_t callback, float offset) {
>     ENCODER_DIRECTION_NORMAL();
>     if (encoderPosition && movesplanned() <= 3) {
>       refresh_cmd_timeout();
>       current_position[axis] += float((int32_t)encoderPosition) * move_menu_scale;
>       if (min_software_endstops) NOLESS(current_position[axis], min);
>       if (max_software_endstops) NOMORE(current_position[axis], max);
>       line_to_current(axis);
>       lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
>     }
>     encoderPosition = 0;
>     if (lcdDrawUpdate) lcd_implementation_drawedit(name, ftostr32(current_position[axis] + offset));
>     if (LCD_CLICKED) (*callback)();
>   }
> #endif
>
>
